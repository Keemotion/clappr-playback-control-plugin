{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///clappr-playback-control-plugin.min.js","webpack:///webpack/bootstrap e22a83a260d08c7ddeb6","webpack:///./src/plugin.js","webpack:///./src/style.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./src/view.html","webpack:///./~/mousetrap/mousetrap.js","webpack:///external \"Clappr\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_clappr","_mousetrap","_mousetrap2","_view","_view2","_style","_style2","SCALE_FRAMES","SCALE_SECONDS","BUTTON_STATE_DOWN","BUTTON_STATE_UP","SX_BUTTON_1","SX_BUTTON_2","SX_BUTTON_3","SX_BUTTON_4","SX_BUTTON_5","buttonSecondsNavMap","playbackRateMapping","-7","-6","-5","-4","-3","-2","-1","0","1","2","3","4","5","6","7","defaults","fps","PlaybackControl","_UICorePlugin","apply","arguments","rate","_this2","manualPlaybackRate","clearInterval","manualPlaybackId","Number","player","pause","updateInterval","setInterval","playback","trigger","destination","bufferingState","console","warn","seekTime","isPlaying","play","invalidate","scale","signed","$el","find","state","button","findButton","children","className","e","sender","currentTarget","getAttribute","seekScaleValue","detail","wheelDelta","stopPropagation","preventDefault","listenTo","mediaControl","Events","MEDIACONTROL_RENDERED","render","MEDIACONTROL_CONTAINERCHANGED","onContainerChanged","reset","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","entries","userInputActionsMap","_step$value","userAction","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","events","_step2$value","event","callback","bind","keys","onMouseWheelDelegate","unbind","style","Styler","getStyleFor","html","template","append","off","on","onButtonClick","onActionsMouseWheel","$","el","stopListening","bindEvents","options","playbackControl","frames","currentTime","getCurrentTime","targetTime","getFPS","getDuration","core","getCurrentPlayback","seek","bufferedTimeRange","buffered","targetFrameBuffered","start","end","seconds","position","isNaN","error","time","seekRelative","seekRelativeFrames","seekRelativeSeconds","PLUGIN_VERSION","class","container","playbackControlConfig","_this3","actions","nav-frame-dec","keydown","highlightButton","keyup","nav-frame-inc","nav-second-dec","nav-second-inc","nav-second-jmp","commandKey","String","fromCharCode","keyCode","togglePlayback","delta","playback-pauseresume","keypress","playback-switchrate","sign","altKey","setManualPlaybackRate","UICorePlugin","list","toString","result","item","join","mediaQuery","alreadyImportedModules","__WEBPACK_AMD_DEFINE_RESULT__","window","document","_addEvent","type","addEventListener","attachEvent","_characterFromEvent","character","which","shiftKey","toLowerCase","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","sort","_eventModifiers","modifiers","ctrlKey","metaKey","_preventDefault","returnValue","_stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","hasOwnProperty","_pickBestAction","action","_keysFromString","combination","replace","split","_getKeyInfo","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","element","ancestor","parentNode","Mousetrap","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","matches","_callbacks","seq","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","stopCallback","srcElement","_handleKeyEvent","_ignoreNextKeyup","handleKey","_resetSequenceTimer","clearTimeout","_resetTimer","setTimeout","_bindSequence","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_bindSingle","_directMap","info","_ignoreNextKeypress","_handleKey","callbacks","maxLevel","processedSequenceCallback","Math","max","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","~","!","@","#","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","option","command","return","escape","plus","mod","test","navigator","platform","indexOf","tagName","isContentEditable","addKeycodes","init","documentMousetrap","method","charAt"],"mappings":"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","file":"clappr-playback-control-plugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Clappr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Clappr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaybackControlPlugin\"] = factory(require(\"Clappr\"));\n\telse\n\t\troot[\"PlaybackControlPlugin\"] = factory(root[\"Clappr\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"Clappr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"Clappr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaybackControlPlugin\"] = factory(require(\"Clappr\"));\n\telse\n\t\troot[\"PlaybackControlPlugin\"] = factory(root[\"Clappr\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"<%=baseUrl%>/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i[\"return\"])_i[\"return\"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if(\"value\"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _clappr=__webpack_require__(5);var _mousetrap=__webpack_require__(4);var _mousetrap2=_interopRequireDefault(_mousetrap);var _view=__webpack_require__(3);var _view2=_interopRequireDefault(_view);var _style=__webpack_require__(1);var _style2=_interopRequireDefault(_style);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/* global PLUGIN_VERSION */// node\n\t// vendors\n\t// project\n\t// locals\n\tvar SCALE_FRAMES='frames';var SCALE_SECONDS='seconds';var BUTTON_STATE_DOWN='down';var BUTTON_STATE_UP='up';var SX_BUTTON_1='1';var SX_BUTTON_2='2';var SX_BUTTON_3='3';var SX_BUTTON_4='4';var SX_BUTTON_5='5';// mappings\n\tvar buttonSecondsNavMap={};buttonSecondsNavMap[SX_BUTTON_1]=-15;buttonSecondsNavMap[SX_BUTTON_2]=-5;buttonSecondsNavMap[SX_BUTTON_4]=+5;buttonSecondsNavMap[SX_BUTTON_5]=+15;var playbackRateMapping={'-7':-32.0,'-6':-16.0,'-5':-8.0,'-4':-4.0,'-3':-2.0,'-2':-1.0,'-1':-0.5,'0':0,'1':0.5,'2':1.0,'3':2.0,'4':4.0,'5':8.0,'6':16.0,'7':32.0};var defaults={fps:29};var PlaybackControl=function(_UICorePlugin){_inherits(PlaybackControl,_UICorePlugin);function PlaybackControl(){_classCallCheck(this,PlaybackControl);return _possibleConstructorReturn(this,Object.getPrototypeOf(PlaybackControl).apply(this,arguments));}_createClass(PlaybackControl,[{key:'setManualPlaybackRate',value:function setManualPlaybackRate(rate){var _this2=this;// do nothing when current rate is equal to received\n\tif(rate===this.manualPlaybackRate){return;}// clear previous virtual playhead\n\tthis.manualPlaybackRate=rate;clearInterval(this.manualPlaybackId);// edge case - 0 means stop motion\n\tif(Number(rate)===0){this.player.pause();return;}//\n\tvar updateInterval=0.1;// every 100 milliseconds\n\tthis.manualPlaybackId=setInterval(function(){_this2.playback.trigger('seeking');var destination=updateInterval*rate;if(_this2.playback.bufferingState){console.warn('cannot seek - buffering, skip at twice the distance');_this2.seekTime(2*destination);}else{_this2.seekTime(destination);}_this2.playback.trigger('waiting');},updateInterval*1000);}},{key:'togglePlayback',value:function togglePlayback(){if(this.player.isPlaying()){this.player.pause();}else{this.player.play();}}// methods\n\t},{key:'onContainerChanged',value:function onContainerChanged(){this.invalidate();}},{key:'findButton',value:function findButton(scale,value){var signed=value>0?'+'+value:value;return this.$el.find('[data-step-scale=\"'+scale+'\"][data-step-value=\"'+signed+'\"]');}},{key:'highlightButton',value:function highlightButton(scale,value,state){var button=this.findButton(scale,value);switch(state){case BUTTON_STATE_DOWN:button.children()[1].className='playback-control-action-highlight';break;case BUTTON_STATE_UP:button.children()[1].className='';break;default:break;}return button;}},{key:'onButtonClick',value:function onButtonClick(e){var sender=e.currentTarget;var scale=sender.getAttribute('data-step-scale');var value=Number(sender.getAttribute('data-step-value'));// control player\n\tthis.seekScaleValue(scale,value);}},{key:'onActionsMouseWheel',value:function onActionsMouseWheel(e){var sender=e.currentTarget;var scale=sender.getAttribute('data-step-scale');var value=e.detail<0||e.wheelDelta>0?1:-1;this.seekScaleValue(scale,value);e.stopPropagation();e.preventDefault();return false;}},{key:'bindEvents',value:function bindEvents(){// discard default clappr events\n\t// const config = this.config;\n\tthis.listenTo(this.mediaControl,_clappr.Events.MEDIACONTROL_RENDERED,this.render);this.listenTo(this.mediaControl,_clappr.Events.MEDIACONTROL_CONTAINERCHANGED,this.onContainerChanged);// non-clappr events\n\t_mousetrap2.default.reset();var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=Object.entries(this.userInputActionsMap)[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var _step$value=_slicedToArray(_step.value,2);var userAction=_step$value[1];var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=Object.entries(userAction.events)[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var _step2$value=_slicedToArray(_step2.value,2);var event=_step2$value[0];var callback=_step2$value[1];_mousetrap2.default.bind(userAction.keys,callback,event);}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally{try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally{if(_didIteratorError2){throw _iteratorError2;}}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}}},{key:'stopListening',value:function stopListening(){_get(Object.getPrototypeOf(PlaybackControl.prototype),'stopListening',this).call(this);// non-clappr events\n\tif(this.onMouseWheelDelegate){this.onMouseWheelDelegate.unbind();this.onMouseWheelDelegate=null;}// remove virtual playback artifacts\n\tthis.manualPlaybackRate=0;clearInterval(this.manualPlaybackId);}},{key:'render',value:function render(){var style=_clappr.Styler.getStyleFor(_style2.default);this.$el.html(this.template()).append(style);this.$el.find('[type=\"button\"]').off('click').on('click',this.onButtonClick.bind(this));this.$el.find('.playback-control-actions').off('DOMMouseScroll').on('DOMMouseScroll',this.onActionsMouseWheel.bind(this));this.$el.find('.playback-control-actions').off('mousewheel').on('mousewheel',this.onActionsMouseWheel.bind(this));this.mediaControl.$('.media-control-left-panel[data-media-control]').append(this.el);return this;}},{key:'invalidate',value:function invalidate(){this.stopListening();this.bindEvents();}},{key:'getFPS',value:function getFPS(){var fps=defaults.fps;if(this.player&&this.player.options&&this.player.options.playbackControl){fps=this.player.options.playbackControl.fps||fps;}return fps;}},{key:'seekRelativeFrames',value:function seekRelativeFrames(frames){var player=this.player;if(player.isPlaying()){player.pause();}var currentTime=player.getCurrentTime();var targetTime=currentTime+frames/this.getFPS();if(targetTime<=0||targetTime>=player.getDuration()){// TODO: decide on how to norm bounds\n\t}else{var playback=this.core.getCurrentPlayback();player.seek(targetTime);// Trigger the waiting event that will buffer the video if targetTime is not buffered yet\n\tvar bufferedTimeRange=playback.el.buffered;var targetFrameBuffered=false;for(var i=0;i<bufferedTimeRange.length;i++){if(targetTime>=bufferedTimeRange.start(i)&&targetTime<=bufferedTimeRange.end(i)){targetFrameBuffered=true;break;}}if(!targetFrameBuffered){playback.trigger('waiting');}}}},{key:'seekRelativeSeconds',value:function seekRelativeSeconds(seconds){var player=this.player;if(player.isPlaying()){player.pause();}var position=player.getCurrentTime()+seconds;if(position<0){position=0;}else if(position>player.getDuration()){position=player.getDuration();}if(position===null||isNaN(position)){console.error('Invalid seek position');}else{player.seek(position);}}},{key:'seekTime',value:function seekTime(time){return this.mediaControl.seekRelative(time);}},{key:'seekScaleValue',value:function seekScaleValue(scale,value){switch(scale){case SCALE_FRAMES:this.seekRelativeFrames(value);break;case SCALE_SECONDS:this.seekRelativeSeconds(value);break;default:break;}}},{key:'name',// properties\n\tget:function get(){return'playback_control';}},{key:'version',get:function get(){return PLUGIN_VERSION;}},{key:'template',get:function get(){return(0,_clappr.template)(_view2.default);}},{key:'attributes',get:function get(){return{class:'playback-control'};}},{key:'mediaControl',get:function get(){return this.core.mediaControl;}},{key:'playback',get:function get(){return this.core.getCurrentPlayback();}},{key:'player',get:function get(){return this.mediaControl.container;}},{key:'config',get:function get(){return this.core.options.playbackControlConfig||defaults;}},{key:'userInputActionsMap',get:function get(){var _this3=this;var actions={// frame navigation\n\t'nav-frame-dec':{keys:['left'],events:{keydown:function keydown(){return _this3.highlightButton(SCALE_FRAMES,-1,BUTTON_STATE_DOWN);},keyup:function keyup(){_this3.highlightButton(SCALE_FRAMES,-1,BUTTON_STATE_UP);_this3.seekScaleValue(SCALE_FRAMES,-1);}}},'nav-frame-inc':{keys:['right'],events:{keydown:function keydown(){return _this3.highlightButton(SCALE_FRAMES,+1,BUTTON_STATE_DOWN);},keyup:function keyup(){_this3.highlightButton(SCALE_FRAMES,+1,BUTTON_STATE_UP);_this3.seekScaleValue(SCALE_FRAMES,+1);}}},// time(second) nagiation\n\t'nav-second-dec':{keys:['down'],events:{keydown:function keydown(){return _this3.highlightButton(SCALE_SECONDS,-1,BUTTON_STATE_DOWN);},keyup:function keyup(){_this3.highlightButton(SCALE_SECONDS,-1,BUTTON_STATE_UP);_this3.seekScaleValue(SCALE_SECONDS,-1);}}},'nav-second-inc':{keys:['up'],events:{keydown:function keydown(){return _this3.highlightButton(SCALE_SECONDS,+1,BUTTON_STATE_DOWN);},keyup:function keyup(){_this3.highlightButton(SCALE_SECONDS,+1,BUTTON_STATE_UP);_this3.seekScaleValue(SCALE_SECONDS,+1);}}},// second based navigation jumps\n\t'nav-second-jmp':{keys:['alt+shift+1','alt+shift+2','alt+shift+3','alt+shift+4','alt+shift+5'],events:{keydown:function keydown(e){var commandKey=String.fromCharCode(e.keyCode);if(commandKey===SX_BUTTON_3){// pause/resume\n\t_this3.togglePlayback();}else{// jump seconds\n\tvar delta=buttonSecondsNavMap[commandKey];_this3.seekScaleValue(SCALE_SECONDS,delta);}}}},// playback control\n\t'playback-pauseresume':{keys:['p'],events:{keypress:function keypress(){return _this3.togglePlayback;}}},'playback-switchrate':{keys:['ctrl+shift+alt+2','ctrl+shift+alt+3','ctrl+shift+alt+4','ctrl+shift+alt+5','ctrl+shift+alt+6','ctrl+shift+alt+7','ctrl+shift+alt+8','ctrl+shift+1',// reset to pause\n\t'ctrl+shift+2','ctrl+shift+3','ctrl+shift+4','ctrl+shift+5','ctrl+shift+6','ctrl+shift+7','ctrl+shift+8'],events:{keydown:function keydown(e){var value=String.fromCharCode(e.keyCode);var sign=e.altKey?-1:1;var key=(Number(value)-1)*sign;var rate=playbackRateMapping[key];_this3.setManualPlaybackRate(rate);}}}};return actions;}}]);return PlaybackControl;}(_clappr.UICorePlugin);exports.default=PlaybackControl;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"[data-player] div.playback-control{float:left}[data-player] div.playback-control>.playback-control-actions{display:inline-block;margin-left:1px;margin-right:1px;height:28px}[data-player] div.playback-control>.playback-control-actions:hover{background:#eee}[data-player] div.playback-control>.playback-control-actions>button{outline:none;cursor:pointer;border:1px solid #444;margin:1px;text-align:center;width:35px;height:26px}[data-player] div.playback-control>.playback-control-actions>button>sub{outline:none;position:relative;display:inline-block;background:#eee;border-radius:15px;width:25px;border:1px solid;left:-2px;bottom:0;font-weight:700;font-family:Consolas,Lucida Console,Monaco,monospace;font-size:11px}[data-player] div.playback-control>.playback-control-actions>button>sub.playback-control-action-highlight{background:#febf04;border-color:#333;color:#333;position:relative;top:1px;left:1px}[data-player] div.playback-control>.playback-control-actions>button:hover{background:#333;color:#eee}[data-player] div.playback-control>.playback-control-actions>button:hover>sub{border-color:#eee;color:#333}[data-player] div.playback-control>.playback-control-actions>button:active{background:#666;color:#333;border-color:#111;position:relative;top:1px}[data-player] div.playback-control>.playback-control-actions>button:active>sub{background:#111;color:#666;border-color:#111;font-weight:700}[data-player] div.playback-control>.playback-control-actions>button::-moz-focus-inner{border:0}[data-player] div.playback-control>.playback-control-actions[data-step-scale=seconds]>button{background:#00b7ea}[data-player] div.playback-control>.playback-control-actions[data-step-scale=frames]>button{background:#d2ff52}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"frames\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame backward\\\">\\n    <p>-1</p>\\n    <sub>&larr;</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame forward\\\">\\n    <p>+1</p>\\n    <sub>&rarr;</sub>\\n  </button>\\n</div>\\n<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"seconds\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second backward\\\">\\n    <p>-1</p>\\n    <sub>&darr;</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second forward\\\">\\n    <p>+1</p>\\n    <sub>&uarr;</sub>\\n  </button>\\n</div>\\n\";\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\t/**\n\t * Copyright 2016 Craig Campbell\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * Mousetrap is a simple keyboard shortcut library for Javascript with\n\t * no external dependencies\n\t *\n\t * @version 1.6.0\n\t * @url craig.is/killing/mice\n\t */\n\t(function(window, document, undefined) {\n\t\n\t    // Check if mousetrap is used inside browser, if not, return\n\t    if (!window) {\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * mapping of special keycodes to their corresponding keys\n\t     *\n\t     * everything in this dictionary cannot use keypress events\n\t     * so it has to be here to map to the correct keycodes for\n\t     * keyup/keydown events\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _MAP = {\n\t        8: 'backspace',\n\t        9: 'tab',\n\t        13: 'enter',\n\t        16: 'shift',\n\t        17: 'ctrl',\n\t        18: 'alt',\n\t        20: 'capslock',\n\t        27: 'esc',\n\t        32: 'space',\n\t        33: 'pageup',\n\t        34: 'pagedown',\n\t        35: 'end',\n\t        36: 'home',\n\t        37: 'left',\n\t        38: 'up',\n\t        39: 'right',\n\t        40: 'down',\n\t        45: 'ins',\n\t        46: 'del',\n\t        91: 'meta',\n\t        93: 'meta',\n\t        224: 'meta'\n\t    };\n\t\n\t    /**\n\t     * mapping for special characters so they can support\n\t     *\n\t     * this dictionary is only used incase you want to bind a\n\t     * keyup or keydown event to one of these keys\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _KEYCODE_MAP = {\n\t        106: '*',\n\t        107: '+',\n\t        109: '-',\n\t        110: '.',\n\t        111 : '/',\n\t        186: ';',\n\t        187: '=',\n\t        188: ',',\n\t        189: '-',\n\t        190: '.',\n\t        191: '/',\n\t        192: '`',\n\t        219: '[',\n\t        220: '\\\\',\n\t        221: ']',\n\t        222: '\\''\n\t    };\n\t\n\t    /**\n\t     * this is a mapping of keys that require shift on a US keypad\n\t     * back to the non shift equivelents\n\t     *\n\t     * this is so you can use keyup events with these keys\n\t     *\n\t     * note that this will only work reliably on US keyboards\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SHIFT_MAP = {\n\t        '~': '`',\n\t        '!': '1',\n\t        '@': '2',\n\t        '#': '3',\n\t        '$': '4',\n\t        '%': '5',\n\t        '^': '6',\n\t        '&': '7',\n\t        '*': '8',\n\t        '(': '9',\n\t        ')': '0',\n\t        '_': '-',\n\t        '+': '=',\n\t        ':': ';',\n\t        '\\\"': '\\'',\n\t        '<': ',',\n\t        '>': '.',\n\t        '?': '/',\n\t        '|': '\\\\'\n\t    };\n\t\n\t    /**\n\t     * this is a list of special strings you can use to map\n\t     * to modifier keys when you specify your keyboard shortcuts\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SPECIAL_ALIASES = {\n\t        'option': 'alt',\n\t        'command': 'meta',\n\t        'return': 'enter',\n\t        'escape': 'esc',\n\t        'plus': '+',\n\t        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n\t    };\n\t\n\t    /**\n\t     * variable to store the flipped version of _MAP from above\n\t     * needed to check if we should use keypress or not when no action\n\t     * is specified\n\t     *\n\t     * @type {Object|undefined}\n\t     */\n\t    var _REVERSE_MAP;\n\t\n\t    /**\n\t     * loop through the f keys, f1 to f19 and add them to the map\n\t     * programatically\n\t     */\n\t    for (var i = 1; i < 20; ++i) {\n\t        _MAP[111 + i] = 'f' + i;\n\t    }\n\t\n\t    /**\n\t     * loop through to map numbers on the numeric keypad\n\t     */\n\t    for (i = 0; i <= 9; ++i) {\n\t        _MAP[i + 96] = i;\n\t    }\n\t\n\t    /**\n\t     * cross browser add event method\n\t     *\n\t     * @param {Element|HTMLDocument} object\n\t     * @param {string} type\n\t     * @param {Function} callback\n\t     * @returns void\n\t     */\n\t    function _addEvent(object, type, callback) {\n\t        if (object.addEventListener) {\n\t            object.addEventListener(type, callback, false);\n\t            return;\n\t        }\n\t\n\t        object.attachEvent('on' + type, callback);\n\t    }\n\t\n\t    /**\n\t     * takes the event and returns the key character\n\t     *\n\t     * @param {Event} e\n\t     * @return {string}\n\t     */\n\t    function _characterFromEvent(e) {\n\t\n\t        // for keypress events we should return the character as is\n\t        if (e.type == 'keypress') {\n\t            var character = String.fromCharCode(e.which);\n\t\n\t            // if the shift key is not pressed then it is safe to assume\n\t            // that we want the character to be lowercase.  this means if\n\t            // you accidentally have caps lock on then your key bindings\n\t            // will continue to work\n\t            //\n\t            // the only side effect that might not be desired is if you\n\t            // bind something like 'A' cause you want to trigger an\n\t            // event when capital A is pressed caps lock will no longer\n\t            // trigger the event.  shift+a will though.\n\t            if (!e.shiftKey) {\n\t                character = character.toLowerCase();\n\t            }\n\t\n\t            return character;\n\t        }\n\t\n\t        // for non keypress events the special maps are needed\n\t        if (_MAP[e.which]) {\n\t            return _MAP[e.which];\n\t        }\n\t\n\t        if (_KEYCODE_MAP[e.which]) {\n\t            return _KEYCODE_MAP[e.which];\n\t        }\n\t\n\t        // if it is not in the special map\n\t\n\t        // with keydown and keyup events the character seems to always\n\t        // come in as an uppercase character whether you are pressing shift\n\t        // or not.  we should make sure it is always lowercase for comparisons\n\t        return String.fromCharCode(e.which).toLowerCase();\n\t    }\n\t\n\t    /**\n\t     * checks if two arrays are equal\n\t     *\n\t     * @param {Array} modifiers1\n\t     * @param {Array} modifiers2\n\t     * @returns {boolean}\n\t     */\n\t    function _modifiersMatch(modifiers1, modifiers2) {\n\t        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n\t    }\n\t\n\t    /**\n\t     * takes a key event and figures out what the modifiers are\n\t     *\n\t     * @param {Event} e\n\t     * @returns {Array}\n\t     */\n\t    function _eventModifiers(e) {\n\t        var modifiers = [];\n\t\n\t        if (e.shiftKey) {\n\t            modifiers.push('shift');\n\t        }\n\t\n\t        if (e.altKey) {\n\t            modifiers.push('alt');\n\t        }\n\t\n\t        if (e.ctrlKey) {\n\t            modifiers.push('ctrl');\n\t        }\n\t\n\t        if (e.metaKey) {\n\t            modifiers.push('meta');\n\t        }\n\t\n\t        return modifiers;\n\t    }\n\t\n\t    /**\n\t     * prevents default for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _preventDefault(e) {\n\t        if (e.preventDefault) {\n\t            e.preventDefault();\n\t            return;\n\t        }\n\t\n\t        e.returnValue = false;\n\t    }\n\t\n\t    /**\n\t     * stops propogation for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _stopPropagation(e) {\n\t        if (e.stopPropagation) {\n\t            e.stopPropagation();\n\t            return;\n\t        }\n\t\n\t        e.cancelBubble = true;\n\t    }\n\t\n\t    /**\n\t     * determines if the keycode specified is a modifier key or not\n\t     *\n\t     * @param {string} key\n\t     * @returns {boolean}\n\t     */\n\t    function _isModifier(key) {\n\t        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n\t    }\n\t\n\t    /**\n\t     * reverses the map lookup so that we can look for specific keys\n\t     * to see what can and can't use keypress\n\t     *\n\t     * @return {Object}\n\t     */\n\t    function _getReverseMap() {\n\t        if (!_REVERSE_MAP) {\n\t            _REVERSE_MAP = {};\n\t            for (var key in _MAP) {\n\t\n\t                // pull out the numeric keypad from here cause keypress should\n\t                // be able to detect the keys from the character\n\t                if (key > 95 && key < 112) {\n\t                    continue;\n\t                }\n\t\n\t                if (_MAP.hasOwnProperty(key)) {\n\t                    _REVERSE_MAP[_MAP[key]] = key;\n\t                }\n\t            }\n\t        }\n\t        return _REVERSE_MAP;\n\t    }\n\t\n\t    /**\n\t     * picks the best action based on the key combination\n\t     *\n\t     * @param {string} key - character for key\n\t     * @param {Array} modifiers\n\t     * @param {string=} action passed in\n\t     */\n\t    function _pickBestAction(key, modifiers, action) {\n\t\n\t        // if no action was picked in we should try to pick the one\n\t        // that we think would work best for this key\n\t        if (!action) {\n\t            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n\t        }\n\t\n\t        // modifier keys don't work as expected with keypress,\n\t        // switch to keydown\n\t        if (action == 'keypress' && modifiers.length) {\n\t            action = 'keydown';\n\t        }\n\t\n\t        return action;\n\t    }\n\t\n\t    /**\n\t     * Converts from a string key combination to an array\n\t     *\n\t     * @param  {string} combination like \"command+shift+l\"\n\t     * @return {Array}\n\t     */\n\t    function _keysFromString(combination) {\n\t        if (combination === '+') {\n\t            return ['+'];\n\t        }\n\t\n\t        combination = combination.replace(/\\+{2}/g, '+plus');\n\t        return combination.split('+');\n\t    }\n\t\n\t    /**\n\t     * Gets info for a specific key combination\n\t     *\n\t     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n\t     * @param  {string=} action\n\t     * @returns {Object}\n\t     */\n\t    function _getKeyInfo(combination, action) {\n\t        var keys;\n\t        var key;\n\t        var i;\n\t        var modifiers = [];\n\t\n\t        // take the keys from this pattern and figure out what the actual\n\t        // pattern is all about\n\t        keys = _keysFromString(combination);\n\t\n\t        for (i = 0; i < keys.length; ++i) {\n\t            key = keys[i];\n\t\n\t            // normalize key names\n\t            if (_SPECIAL_ALIASES[key]) {\n\t                key = _SPECIAL_ALIASES[key];\n\t            }\n\t\n\t            // if this is not a keypress event then we should\n\t            // be smart about using shift keys\n\t            // this will only work for US keyboards however\n\t            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n\t                key = _SHIFT_MAP[key];\n\t                modifiers.push('shift');\n\t            }\n\t\n\t            // if this key is a modifier then add it to the list of modifiers\n\t            if (_isModifier(key)) {\n\t                modifiers.push(key);\n\t            }\n\t        }\n\t\n\t        // depending on what the key combination is\n\t        // we will try to pick the best event for it\n\t        action = _pickBestAction(key, modifiers, action);\n\t\n\t        return {\n\t            key: key,\n\t            modifiers: modifiers,\n\t            action: action\n\t        };\n\t    }\n\t\n\t    function _belongsTo(element, ancestor) {\n\t        if (element === null || element === document) {\n\t            return false;\n\t        }\n\t\n\t        if (element === ancestor) {\n\t            return true;\n\t        }\n\t\n\t        return _belongsTo(element.parentNode, ancestor);\n\t    }\n\t\n\t    function Mousetrap(targetElement) {\n\t        var self = this;\n\t\n\t        targetElement = targetElement || document;\n\t\n\t        if (!(self instanceof Mousetrap)) {\n\t            return new Mousetrap(targetElement);\n\t        }\n\t\n\t        /**\n\t         * element to attach key events to\n\t         *\n\t         * @type {Element}\n\t         */\n\t        self.target = targetElement;\n\t\n\t        /**\n\t         * a list of all the callbacks setup via Mousetrap.bind()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._callbacks = {};\n\t\n\t        /**\n\t         * direct map of string combinations to callbacks used for trigger()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._directMap = {};\n\t\n\t        /**\n\t         * keeps track of what level each sequence is at since multiple\n\t         * sequences can start out with the same sequence\n\t         *\n\t         * @type {Object}\n\t         */\n\t        var _sequenceLevels = {};\n\t\n\t        /**\n\t         * variable to store the setTimeout call\n\t         *\n\t         * @type {null|number}\n\t         */\n\t        var _resetTimer;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keyup\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _ignoreNextKeyup = false;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keypress\n\t         *\n\t         * @type {boolean}\n\t         */\n\t        var _ignoreNextKeypress = false;\n\t\n\t        /**\n\t         * are we currently inside of a sequence?\n\t         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _nextExpectedAction = false;\n\t\n\t        /**\n\t         * resets all sequence counters except for the ones passed in\n\t         *\n\t         * @param {Object} doNotReset\n\t         * @returns void\n\t         */\n\t        function _resetSequences(doNotReset) {\n\t            doNotReset = doNotReset || {};\n\t\n\t            var activeSequences = false,\n\t                key;\n\t\n\t            for (key in _sequenceLevels) {\n\t                if (doNotReset[key]) {\n\t                    activeSequences = true;\n\t                    continue;\n\t                }\n\t                _sequenceLevels[key] = 0;\n\t            }\n\t\n\t            if (!activeSequences) {\n\t                _nextExpectedAction = false;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * finds all callbacks that match based on the keycode, modifiers,\n\t         * and action\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event|Object} e\n\t         * @param {string=} sequenceName - name of the sequence we are looking for\n\t         * @param {string=} combination\n\t         * @param {number=} level\n\t         * @returns {Array}\n\t         */\n\t        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n\t            var i;\n\t            var callback;\n\t            var matches = [];\n\t            var action = e.type;\n\t\n\t            // if there are no events related to this keycode\n\t            if (!self._callbacks[character]) {\n\t                return [];\n\t            }\n\t\n\t            // if a modifier key is coming up on its own we should allow it\n\t            if (action == 'keyup' && _isModifier(character)) {\n\t                modifiers = [character];\n\t            }\n\t\n\t            // loop through all callbacks for the key that was pressed\n\t            // and see if any of them match\n\t            for (i = 0; i < self._callbacks[character].length; ++i) {\n\t                callback = self._callbacks[character][i];\n\t\n\t                // if a sequence name is not specified, but this is a sequence at\n\t                // the wrong level then move onto the next match\n\t                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n\t                    continue;\n\t                }\n\t\n\t                // if the action we are looking for doesn't match the action we got\n\t                // then we should keep going\n\t                if (action != callback.action) {\n\t                    continue;\n\t                }\n\t\n\t                // if this is a keypress event and the meta key and control key\n\t                // are not pressed that means that we need to only look at the\n\t                // character, otherwise check the modifiers as well\n\t                //\n\t                // chrome will not fire a keypress if meta or control is down\n\t                // safari will fire a keypress if meta or meta+shift is down\n\t                // firefox will fire a keypress if meta or control is down\n\t                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\t\n\t                    // when you bind a combination or sequence a second time it\n\t                    // should overwrite the first one.  if a sequenceName or\n\t                    // combination is specified in this call it does just that\n\t                    //\n\t                    // @todo make deleting its own method?\n\t                    var deleteCombo = !sequenceName && callback.combo == combination;\n\t                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\t                    if (deleteCombo || deleteSequence) {\n\t                        self._callbacks[character].splice(i, 1);\n\t                    }\n\t\n\t                    matches.push(callback);\n\t                }\n\t            }\n\t\n\t            return matches;\n\t        }\n\t\n\t        /**\n\t         * actually calls the callback function\n\t         *\n\t         * if your callback function returns false this will use the jquery\n\t         * convention - prevent default and stop propogation on the event\n\t         *\n\t         * @param {Function} callback\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _fireCallback(callback, e, combo, sequence) {\n\t\n\t            // if this event should not happen stop here\n\t            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n\t                return;\n\t            }\n\t\n\t            if (callback(e, combo) === false) {\n\t                _preventDefault(e);\n\t                _stopPropagation(e);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * handles a character key event\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        self._handleKey = function(character, modifiers, e) {\n\t            var callbacks = _getMatches(character, modifiers, e);\n\t            var i;\n\t            var doNotReset = {};\n\t            var maxLevel = 0;\n\t            var processedSequenceCallback = false;\n\t\n\t            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t                if (callbacks[i].seq) {\n\t                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n\t                }\n\t            }\n\t\n\t            // loop through matching callbacks for this key event\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t\n\t                // fire for all sequence callbacks\n\t                // this is because if for example you have multiple sequences\n\t                // bound such as \"g i\" and \"g t\" they both need to fire the\n\t                // callback for matching g cause otherwise you can only ever\n\t                // match the first one\n\t                if (callbacks[i].seq) {\n\t\n\t                    // only fire callbacks for the maxLevel to prevent\n\t                    // subsequences from also firing\n\t                    //\n\t                    // for example 'a option b' should not cause 'option b' to fire\n\t                    // even though 'option b' is part of the other sequence\n\t                    //\n\t                    // any sequences that do not match here will be discarded\n\t                    // below by the _resetSequences call\n\t                    if (callbacks[i].level != maxLevel) {\n\t                        continue;\n\t                    }\n\t\n\t                    processedSequenceCallback = true;\n\t\n\t                    // keep a list of which sequences were matches for later\n\t                    doNotReset[callbacks[i].seq] = 1;\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\t                    continue;\n\t                }\n\t\n\t                // if there were no sequence matches but we are still here\n\t                // that means this is a regular match so we should fire that\n\t                if (!processedSequenceCallback) {\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n\t                }\n\t            }\n\t\n\t            // if the key you pressed matches the type of sequence without\n\t            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n\t            // reset all sequences that were not matched by this event\n\t            //\n\t            // this is so, for example, if you have the sequence \"h a t\" and you\n\t            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n\t            // cause the sequence to reset\n\t            //\n\t            // modifier keys are ignored because you can have a sequence\n\t            // that contains modifiers such as \"enter ctrl+space\" and in most\n\t            // cases the modifier key will be pressed before the next key\n\t            //\n\t            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n\t            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n\t            //\n\t            // the \"keydown\" is expected when there is a modifier, but the\n\t            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n\t            // after and that causes the sequence to reset\n\t            //\n\t            // we ignore keypresses in a sequence that directly follow a keydown\n\t            // for the same character\n\t            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\t            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n\t                _resetSequences(doNotReset);\n\t            }\n\t\n\t            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n\t        };\n\t\n\t        /**\n\t         * handles a keydown event\n\t         *\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _handleKeyEvent(e) {\n\t\n\t            // normalize e.which for key events\n\t            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n\t            if (typeof e.which !== 'number') {\n\t                e.which = e.keyCode;\n\t            }\n\t\n\t            var character = _characterFromEvent(e);\n\t\n\t            // no character found then stop\n\t            if (!character) {\n\t                return;\n\t            }\n\t\n\t            // need to use === for the character check because the character can be 0\n\t            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n\t                _ignoreNextKeyup = false;\n\t                return;\n\t            }\n\t\n\t            self.handleKey(character, _eventModifiers(e), e);\n\t        }\n\t\n\t        /**\n\t         * called to set a 1 second timeout on the specified sequence\n\t         *\n\t         * this is so after each key press in the sequence you have 1 second\n\t         * to press the next key before you have to start over\n\t         *\n\t         * @returns void\n\t         */\n\t        function _resetSequenceTimer() {\n\t            clearTimeout(_resetTimer);\n\t            _resetTimer = setTimeout(_resetSequences, 1000);\n\t        }\n\t\n\t        /**\n\t         * binds a key sequence to an event\n\t         *\n\t         * @param {string} combo - combo specified in bind call\n\t         * @param {Array} keys\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @returns void\n\t         */\n\t        function _bindSequence(combo, keys, callback, action) {\n\t\n\t            // start off by adding a sequence level record for this combination\n\t            // and setting the level to 0\n\t            _sequenceLevels[combo] = 0;\n\t\n\t            /**\n\t             * callback to increase the sequence level for this sequence and reset\n\t             * all other sequences that were active\n\t             *\n\t             * @param {string} nextAction\n\t             * @returns {Function}\n\t             */\n\t            function _increaseSequence(nextAction) {\n\t                return function() {\n\t                    _nextExpectedAction = nextAction;\n\t                    ++_sequenceLevels[combo];\n\t                    _resetSequenceTimer();\n\t                };\n\t            }\n\t\n\t            /**\n\t             * wraps the specified callback inside of another function in order\n\t             * to reset all sequence counters as soon as this sequence is done\n\t             *\n\t             * @param {Event} e\n\t             * @returns void\n\t             */\n\t            function _callbackAndReset(e) {\n\t                _fireCallback(callback, e, combo);\n\t\n\t                // we should ignore the next key up if the action is key down\n\t                // or keypress.  this is so if you finish a sequence and\n\t                // release the key the final key will not trigger a keyup\n\t                if (action !== 'keyup') {\n\t                    _ignoreNextKeyup = _characterFromEvent(e);\n\t                }\n\t\n\t                // weird race condition if a sequence ends with the key\n\t                // another sequence begins with\n\t                setTimeout(_resetSequences, 10);\n\t            }\n\t\n\t            // loop through keys one at a time and bind the appropriate callback\n\t            // function.  for any key leading up to the final one it should\n\t            // increase the sequence. after the final, it should reset all sequences\n\t            //\n\t            // if an action is specified in the original bind call then that will\n\t            // be used throughout.  otherwise we will pass the action that the\n\t            // next key in the sequence should match.  this allows a sequence\n\t            // to mix and match keypress and keydown events depending on which\n\t            // ones are better suited to the key provided\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var isFinal = i + 1 === keys.length;\n\t                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\t                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * binds a single keyboard combination\n\t         *\n\t         * @param {string} combination\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @param {string=} sequenceName - name of sequence if part of sequence\n\t         * @param {number=} level - what part of the sequence the command is\n\t         * @returns void\n\t         */\n\t        function _bindSingle(combination, callback, action, sequenceName, level) {\n\t\n\t            // store a direct mapped reference for use with Mousetrap.trigger\n\t            self._directMap[combination + ':' + action] = callback;\n\t\n\t            // make sure multiple spaces in a row become a single space\n\t            combination = combination.replace(/\\s+/g, ' ');\n\t\n\t            var sequence = combination.split(' ');\n\t            var info;\n\t\n\t            // if this pattern is a sequence of keys then run through this method\n\t            // to reprocess each pattern one key at a time\n\t            if (sequence.length > 1) {\n\t                _bindSequence(combination, sequence, callback, action);\n\t                return;\n\t            }\n\t\n\t            info = _getKeyInfo(combination, action);\n\t\n\t            // make sure to initialize array if this is the first time\n\t            // a callback is added for this key\n\t            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\t\n\t            // remove an existing match if there is one\n\t            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\t\n\t            // add this call back to the array\n\t            // if it is a sequence put it at the beginning\n\t            // if not put it at the end\n\t            //\n\t            // this is important because the way these are processed expects\n\t            // the sequence ones to come first\n\t            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n\t                callback: callback,\n\t                modifiers: info.modifiers,\n\t                action: info.action,\n\t                seq: sequenceName,\n\t                level: level,\n\t                combo: combination\n\t            });\n\t        }\n\t\n\t        /**\n\t         * binds multiple combinations to the same callback\n\t         *\n\t         * @param {Array} combinations\n\t         * @param {Function} callback\n\t         * @param {string|undefined} action\n\t         * @returns void\n\t         */\n\t        self._bindMultiple = function(combinations, callback, action) {\n\t            for (var i = 0; i < combinations.length; ++i) {\n\t                _bindSingle(combinations[i], callback, action);\n\t            }\n\t        };\n\t\n\t        // start!\n\t        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n\t    }\n\t\n\t    /**\n\t     * binds an event to mousetrap\n\t     *\n\t     * can be a single key, a combination of keys separated with +,\n\t     * an array of keys, or a sequence of keys separated by spaces\n\t     *\n\t     * be sure to list the modifier keys first to make sure that the\n\t     * correct key ends up getting bound (the last key in the pattern)\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {Function} callback\n\t     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.bind = function(keys, callback, action) {\n\t        var self = this;\n\t        keys = keys instanceof Array ? keys : [keys];\n\t        self._bindMultiple.call(self, keys, callback, action);\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * unbinds an event to mousetrap\n\t     *\n\t     * the unbinding sets the callback function of the specified key combo\n\t     * to an empty function and deletes the corresponding key in the\n\t     * _directMap dict.\n\t     *\n\t     * TODO: actually remove this from the _callbacks dictionary instead\n\t     * of binding an empty function\n\t     *\n\t     * the keycombo+action has to be exactly the same as\n\t     * it was defined in the bind method\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {string} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.unbind = function(keys, action) {\n\t        var self = this;\n\t        return self.bind.call(self, keys, function() {}, action);\n\t    };\n\t\n\t    /**\n\t     * triggers an event that has already been bound\n\t     *\n\t     * @param {string} keys\n\t     * @param {string=} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.trigger = function(keys, action) {\n\t        var self = this;\n\t        if (self._directMap[keys + ':' + action]) {\n\t            self._directMap[keys + ':' + action]({}, keys);\n\t        }\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * resets the library back to its initial state.  this is useful\n\t     * if you want to clear out the current keyboard shortcuts and bind\n\t     * new ones - for example if you switch to another page\n\t     *\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.reset = function() {\n\t        var self = this;\n\t        self._callbacks = {};\n\t        self._directMap = {};\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * should we stop this event before firing off callbacks\n\t     *\n\t     * @param {Event} e\n\t     * @param {Element} element\n\t     * @return {boolean}\n\t     */\n\t    Mousetrap.prototype.stopCallback = function(e, element) {\n\t        var self = this;\n\t\n\t        // if the element has the class \"mousetrap\" then no need to stop\n\t        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n\t            return false;\n\t        }\n\t\n\t        if (_belongsTo(element, self.target)) {\n\t            return false;\n\t        }\n\t\n\t        // stop for input, select, and textarea\n\t        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n\t    };\n\t\n\t    /**\n\t     * exposes _handleKey publicly so it can be overwritten by extensions\n\t     */\n\t    Mousetrap.prototype.handleKey = function() {\n\t        var self = this;\n\t        return self._handleKey.apply(self, arguments);\n\t    };\n\t\n\t    /**\n\t     * allow custom key mappings\n\t     */\n\t    Mousetrap.addKeycodes = function(object) {\n\t        for (var key in object) {\n\t            if (object.hasOwnProperty(key)) {\n\t                _MAP[key] = object[key];\n\t            }\n\t        }\n\t        _REVERSE_MAP = null;\n\t    };\n\t\n\t    /**\n\t     * Init the global mousetrap functions\n\t     *\n\t     * This method is needed to allow the global mousetrap functions to work\n\t     * now that mousetrap is a constructor function.\n\t     */\n\t    Mousetrap.init = function() {\n\t        var documentMousetrap = Mousetrap(document);\n\t        for (var method in documentMousetrap) {\n\t            if (method.charAt(0) !== '_') {\n\t                Mousetrap[method] = (function(method) {\n\t                    return function() {\n\t                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n\t                    };\n\t                } (method));\n\t            }\n\t        }\n\t    };\n\t\n\t    Mousetrap.init();\n\t\n\t    // expose mousetrap to the global object\n\t    window.Mousetrap = Mousetrap;\n\t\n\t    // expose as a common js module\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = Mousetrap;\n\t    }\n\t\n\t    // expose mousetrap as an AMD module\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t            return Mousetrap;\n\t        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** clappr-playback-control-plugin.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"<%=baseUrl%>/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e22a83a260d08c7ddeb6\n **/","/* global PLUGIN_VERSION */\n// node\n// vendors\nimport { UICorePlugin, template, Events, Styler } from 'clappr';\nimport Mousetrap from 'mousetrap';\n// project\nimport PlaybackControlHTML from './view.html';\nimport PlaybackControlCSS from './style.scss';\n\n// locals\nconst SCALE_FRAMES = 'frames';\nconst SCALE_SECONDS = 'seconds';\nconst BUTTON_STATE_DOWN = 'down';\nconst BUTTON_STATE_UP = 'up';\n\nconst SX_BUTTON_1 = '1';\nconst SX_BUTTON_2 = '2';\nconst SX_BUTTON_3 = '3';\nconst SX_BUTTON_4 = '4';\nconst SX_BUTTON_5 = '5';\n\n// mappings\nvar buttonSecondsNavMap = {};\nbuttonSecondsNavMap[SX_BUTTON_1] = -15;\nbuttonSecondsNavMap[SX_BUTTON_2] = -5;\nbuttonSecondsNavMap[SX_BUTTON_4] = +5;\nbuttonSecondsNavMap[SX_BUTTON_5] = +15;\n\nconst playbackRateMapping = {\n  '-7': -32.0,\n  '-6': -16.0,\n  '-5': -8.0,\n  '-4': -4.0,\n  '-3': -2.0,\n  '-2': -1.0,\n  '-1': -0.5,\n  '0': 0,\n  '1': 0.5,\n  '2': 1.0,\n  '3': 2.0,\n  '4': 4.0,\n  '5': 8.0,\n  '6': 16.0,\n  '7': 32.0\n};\n\nconst defaults = {\n  fps: 29\n};\n\nclass PlaybackControl extends UICorePlugin {\n  // properties\n  get name() { return 'playback_control'; }\n  get version() { return PLUGIN_VERSION; }\n  get template() { return template(PlaybackControlHTML); }\n  get attributes() { return { class: 'playback-control' }; }\n  get mediaControl() { return this.core.mediaControl; }\n  get playback() { return this.core.getCurrentPlayback(); }\n  get player() { return this.mediaControl.container; }\n  get config() { return this.core.options.playbackControlConfig || defaults; }\n  get userInputActionsMap() {\n    const actions = {\n      // frame navigation\n      'nav-frame-dec': {\n        keys: ['left'],\n        events: {\n          keydown: () => this.highlightButton(SCALE_FRAMES, -1, BUTTON_STATE_DOWN),\n          keyup: () => {\n            this.highlightButton(SCALE_FRAMES, -1, BUTTON_STATE_UP);\n            this.seekScaleValue(SCALE_FRAMES, -1);\n          }\n        }\n      },\n      'nav-frame-inc': {\n        keys: ['right'],\n        events: {\n          keydown: () => this.highlightButton(SCALE_FRAMES, +1, BUTTON_STATE_DOWN),\n          keyup: () => {\n            this.highlightButton(SCALE_FRAMES, +1, BUTTON_STATE_UP);\n            this.seekScaleValue(SCALE_FRAMES, +1);\n          }\n        }\n      },\n      // time(second) nagiation\n      'nav-second-dec': {\n        keys: ['down'],\n        events: {\n          keydown: () => this.highlightButton(SCALE_SECONDS, -1, BUTTON_STATE_DOWN),\n          keyup: () => {\n            this.highlightButton(SCALE_SECONDS, -1, BUTTON_STATE_UP);\n            this.seekScaleValue(SCALE_SECONDS, -1);\n          }\n        }\n      },\n      'nav-second-inc': {\n        keys: ['up'],\n        events: {\n          keydown: () => this.highlightButton(SCALE_SECONDS, +1, BUTTON_STATE_DOWN),\n          keyup: () => {\n            this.highlightButton(SCALE_SECONDS, +1, BUTTON_STATE_UP);\n            this.seekScaleValue(SCALE_SECONDS, +1);\n          }\n        }\n      },\n      // second based navigation jumps\n      'nav-second-jmp': {\n        keys: [\n          'alt+shift+1',\n          'alt+shift+2',\n          'alt+shift+3',\n          'alt+shift+4',\n          'alt+shift+5'\n        ],\n        events: {\n          keydown: (e) => {\n            var commandKey = String.fromCharCode(e.keyCode);\n            if (commandKey === SX_BUTTON_3) {\n              // pause/resume\n              this.togglePlayback();\n            } else {\n              // jump seconds\n              var delta = buttonSecondsNavMap[commandKey];\n              this.seekScaleValue(SCALE_SECONDS, delta);\n            }\n          }\n        }\n      },\n      // playback control\n      'playback-pauseresume': {\n        keys: ['p'],\n        events: {\n          keypress: () => this.togglePlayback\n        }\n      },\n      'playback-switchrate': {\n        keys: [\n          'ctrl+shift+alt+2',\n          'ctrl+shift+alt+3',\n          'ctrl+shift+alt+4',\n          'ctrl+shift+alt+5',\n          'ctrl+shift+alt+6',\n          'ctrl+shift+alt+7',\n          'ctrl+shift+alt+8',\n          'ctrl+shift+1', // reset to pause\n          'ctrl+shift+2',\n          'ctrl+shift+3',\n          'ctrl+shift+4',\n          'ctrl+shift+5',\n          'ctrl+shift+6',\n          'ctrl+shift+7',\n          'ctrl+shift+8'\n        ],\n        events: {\n          keydown: (e) => {\n            var value = String.fromCharCode(e.keyCode);\n            var sign = e.altKey ? -1 : 1;\n            var key = (Number(value) - 1) * sign;\n            var rate = playbackRateMapping[key];\n            this.setManualPlaybackRate(rate);\n          }\n        }\n      }\n    };\n    return actions;\n  }\n  setManualPlaybackRate(rate) {\n    // do nothing when current rate is equal to received\n    if (rate === this.manualPlaybackRate) {\n      return;\n    }\n    // clear previous virtual playhead\n    this.manualPlaybackRate = rate;\n    clearInterval(this.manualPlaybackId);\n    // edge case - 0 means stop motion\n    if (Number(rate) === 0) {\n      this.player.pause();\n      return;\n    }\n    //\n    const updateInterval = 0.1; // every 100 milliseconds\n    this.manualPlaybackId = setInterval(() => {\n      this.playback.trigger('seeking');\n      var destination = updateInterval * rate;\n      if (this.playback.bufferingState) {\n        console.warn('cannot seek - buffering, skip at twice the distance');\n        this.seekTime(2 * destination);\n      } else {\n        this.seekTime(destination);\n      }\n      this.playback.trigger('waiting');\n    }, updateInterval * 1000);\n  }\n  togglePlayback() {\n    if (this.player.isPlaying()) {\n      this.player.pause();\n    } else {\n      this.player.play();\n    }\n  }\n  // methods\n  onContainerChanged() {\n    this.invalidate();\n  }\n  findButton(scale, value) {\n    const signed = value > 0 ? `+${value}` : value;\n    return this.$el.find(`[data-step-scale=\"${scale}\"][data-step-value=\"${signed}\"]`);\n  }\n  highlightButton(scale, value, state) {\n    const button = this.findButton(scale, value);\n    switch (state) {\n    case BUTTON_STATE_DOWN:\n      button.children()[1].className = 'playback-control-action-highlight';\n      break;\n    case BUTTON_STATE_UP:\n      button.children()[1].className = '';\n      break;\n    default:\n      break;\n    }\n    return button;\n  }\n  onButtonClick(e) {\n    const sender = e.currentTarget;\n    const scale = sender.getAttribute('data-step-scale');\n    const value = Number(sender.getAttribute('data-step-value'));\n    // control player\n    this.seekScaleValue(scale, value);\n  }\n  onActionsMouseWheel(e) {\n    const sender = e.currentTarget;\n    const scale = sender.getAttribute('data-step-scale');\n    const value = ((e.detail < 0) || (e.wheelDelta > 0)) ? 1 : -1;\n    this.seekScaleValue(scale, value);\n    e.stopPropagation();\n    e.preventDefault();\n    return false;\n  }\n  bindEvents() {\n    // discard default clappr events\n    // const config = this.config;\n    this.listenTo(this.mediaControl, Events.MEDIACONTROL_RENDERED, this.render);\n    this.listenTo(this.mediaControl, Events.MEDIACONTROL_CONTAINERCHANGED, this.onContainerChanged);\n    // non-clappr events\n    Mousetrap.reset();\n    for (let [, userAction] of Object.entries(this.userInputActionsMap)) {\n      for (let [event, callback] of Object.entries(userAction.events)) {\n        Mousetrap.bind(userAction.keys, callback, event);\n      }\n    }\n  }\n  stopListening() {\n    super.stopListening();\n    // non-clappr events\n    if (this.onMouseWheelDelegate) {\n      this.onMouseWheelDelegate.unbind();\n      this.onMouseWheelDelegate = null;\n    }\n    // remove virtual playback artifacts\n    this.manualPlaybackRate = 0;\n    clearInterval(this.manualPlaybackId);\n  }\n  render() {\n    const style = Styler.getStyleFor(PlaybackControlCSS);\n    this.$el\n      .html(this.template())\n      .append(style);\n    this.$el\n      .find('[type=\"button\"]')\n      .off('click')\n      .on('click', this.onButtonClick.bind(this));\n    this.$el\n      .find('.playback-control-actions')\n      .off('DOMMouseScroll')\n      .on('DOMMouseScroll', this.onActionsMouseWheel.bind(this));\n    this.$el\n      .find('.playback-control-actions')\n      .off('mousewheel')\n      .on('mousewheel', this.onActionsMouseWheel.bind(this));\n    this.mediaControl\n      .$('.media-control-left-panel[data-media-control]')\n      .append(this.el);\n    return this;\n  }\n  invalidate() {\n    this.stopListening();\n    this.bindEvents();\n  }\n  getFPS() {\n    let fps = defaults.fps;\n    if (this.player && this.player.options && this.player.options.playbackControl) {\n      fps = this.player.options.playbackControl.fps || fps;\n    }\n    return fps;\n  }\n  seekRelativeFrames(frames) {\n    const player = this.player;\n    if (player.isPlaying()) {\n      player.pause();\n    }\n    const currentTime = player.getCurrentTime();\n    const targetTime = currentTime + (frames / this.getFPS());\n    if ((targetTime <= 0) || (targetTime >= player.getDuration())) {\n      // TODO: decide on how to norm bounds\n    } else {\n      const playback = this.core.getCurrentPlayback();\n      player.seek(targetTime);\n      // Trigger the waiting event that will buffer the video if targetTime is not buffered yet\n      const bufferedTimeRange = playback.el.buffered;\n      let targetFrameBuffered = false;\n      for (let i = 0; i < bufferedTimeRange.length; i++) {\n        if ((targetTime >= bufferedTimeRange.start(i)) && (targetTime <= bufferedTimeRange.end(i))) {\n          targetFrameBuffered = true;\n          break;\n        }\n      }\n      if (!targetFrameBuffered) {\n        playback.trigger('waiting');\n      }\n    }\n  }\n  seekRelativeSeconds(seconds) {\n    const player = this.player;\n    if (player.isPlaying()) {\n      player.pause();\n    }\n    let position = player.getCurrentTime() + seconds;\n    if (position < 0) {\n      position = 0;\n    } else if (position > player.getDuration()) {\n      position = player.getDuration();\n    }\n    if ((position === null) || isNaN(position)) {\n      console.error('Invalid seek position');\n    } else {\n      player.seek(position);\n    }\n  }\n  seekTime(time) {\n    return this.mediaControl.seekRelative(time);\n  }\n  seekScaleValue(scale, value) {\n    switch (scale) {\n    case SCALE_FRAMES:\n      this.seekRelativeFrames(value);\n      break;\n    case SCALE_SECONDS:\n      this.seekRelativeSeconds(value);\n      break;\n    default:\n      break;\n    }\n  }\n}\n\nexport default PlaybackControl;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/plugin.js\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"[data-player] div.playback-control{float:left}[data-player] div.playback-control>.playback-control-actions{display:inline-block;margin-left:1px;margin-right:1px;height:28px}[data-player] div.playback-control>.playback-control-actions:hover{background:#eee}[data-player] div.playback-control>.playback-control-actions>button{outline:none;cursor:pointer;border:1px solid #444;margin:1px;text-align:center;width:35px;height:26px}[data-player] div.playback-control>.playback-control-actions>button>sub{outline:none;position:relative;display:inline-block;background:#eee;border-radius:15px;width:25px;border:1px solid;left:-2px;bottom:0;font-weight:700;font-family:Consolas,Lucida Console,Monaco,monospace;font-size:11px}[data-player] div.playback-control>.playback-control-actions>button>sub.playback-control-action-highlight{background:#febf04;border-color:#333;color:#333;position:relative;top:1px;left:1px}[data-player] div.playback-control>.playback-control-actions>button:hover{background:#333;color:#eee}[data-player] div.playback-control>.playback-control-actions>button:hover>sub{border-color:#eee;color:#333}[data-player] div.playback-control>.playback-control-actions>button:active{background:#666;color:#333;border-color:#111;position:relative;top:1px}[data-player] div.playback-control>.playback-control-actions>button:active>sub{background:#111;color:#666;border-color:#111;font-weight:700}[data-player] div.playback-control>.playback-control-actions>button::-moz-focus-inner{border:0}[data-player] div.playback-control>.playback-control-actions[data-step-scale=seconds]>button{background:#00b7ea}[data-player] div.playback-control>.playback-control-actions[data-step-scale=frames]>button{background:#d2ff52}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/style.scss\n ** module id = 1\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = \"<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"frames\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame backward\\\">\\n    <p>-1</p>\\n    <sub>&larr;</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame forward\\\">\\n    <p>+1</p>\\n    <sub>&rarr;</sub>\\n  </button>\\n</div>\\n<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"seconds\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second backward\\\">\\n    <p>-1</p>\\n    <sub>&darr;</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second forward\\\">\\n    <p>+1</p>\\n    <sub>&uarr;</sub>\\n  </button>\\n</div>\\n\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/view.html\n ** module id = 3\n ** module chunks = 0\n **/","/*global define:false */\n/**\n * Copyright 2016 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.0\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n        _MAP[i + 96] = i;\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mousetrap/mousetrap.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"Clappr\"\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}