{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///clappr-playback-control-plugin.min.js","webpack:///webpack/bootstrap 96a71d191c67f51c6c80","webpack:///./src/plugin.js","webpack:///./src/style.scss","webpack:///./~/css-loader/lib/css-base.js","webpack:///./src/view.html","webpack:///./~/mousetrap/mousetrap.js","webpack:///external \"clappr\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_5__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","parent","getPrototypeOf","getter","_clappr","_clappr2","_mousetrap","_mousetrap2","_view","_view2","_style","_style2","SCALE_FRAMES","SCALE_SECONDS","BUTTON_STATE_DOWN","BUTTON_STATE_UP","FPS_DEFAULT","PlaybackControl","_Clappr$UICorePlugin","apply","arguments","invalidate","scale","seekRelativeFrames","seekRelativeSeconds","signed","$el","find","state","button","findButton","children","className","e","sender","currentTarget","getAttribute","Number","seekScaleValue","detail","wheelDelta","stopPropagation","preventDefault","_this2","player","listenTo","mediaControl","Events","MEDIACONTROL_RENDERED","render","MEDIACONTROL_CONTAINERCHANGED","onContainerChanged","addKeycodes","144","bind","highlightButton","isPlaying","pause","play","switchPlaybackRate","rate","trigger","onMouseWheelDelegate","unbind","style","Styler","getStyleFor","html","template","append","off","on","onButtonClick","onActionsMouseWheel","$","el","stopListening","bindEvents","fps","options","playbackControl","frames","currentTime","getCurrentTime","targetTime","getFPS","getDuration","playback","core","getCurrentPlayback","seek","bufferedTimeRange","buffered","targetFrameBuffered","start","end","seconds","position","PLUGIN_VERSION","class","container","playbackControlConfig","keyBindings","UICorePlugin","push","list","toString","result","item","join","mediaQuery","alreadyImportedModules","__WEBPACK_AMD_DEFINE_RESULT__","window","document","_addEvent","type","callback","addEventListener","attachEvent","_characterFromEvent","character","String","fromCharCode","which","shiftKey","toLowerCase","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","sort","_eventModifiers","modifiers","altKey","ctrlKey","metaKey","_preventDefault","returnValue","_stopPropagation","cancelBubble","_isModifier","_getReverseMap","_REVERSE_MAP","hasOwnProperty","_pickBestAction","action","_keysFromString","combination","replace","split","_getKeyInfo","keys","_SPECIAL_ALIASES","_SHIFT_MAP","_belongsTo","element","ancestor","parentNode","Mousetrap","targetElement","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","sequenceName","level","matches","_callbacks","seq","deleteCombo","combo","deleteSequence","splice","_fireCallback","sequence","stopCallback","srcElement","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","clearTimeout","_resetTimer","setTimeout","_bindSequence","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_bindSingle","_directMap","info","_ignoreNextKeypress","_handleKey","callbacks","maxLevel","processedSequenceCallback","Math","max","ignoreThisKeypress","_bindMultiple","combinations","8","9","13","16","17","18","20","27","32","33","34","35","36","37","38","39","40","45","46","91","93","224","106","107","109","110","111","186","187","188","189","190","191","192","219","220","221","222","~","!","@","#","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","option","command","return","escape","plus","mod","test","navigator","platform","Array","reset","indexOf","tagName","isContentEditable","init","documentMousetrap","method","charAt"],"mappings":"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","file":"clappr-playback-control-plugin.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"clappr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"clappr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaybackControlPlugin\"] = factory(require(\"clappr\"));\n\telse\n\t\troot[\"PlaybackControlPlugin\"] = factory(root[\"clappr\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"clappr\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"clappr\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PlaybackControlPlugin\"] = factory(require(\"clappr\"));\n\telse\n\t\troot[\"PlaybackControlPlugin\"] = factory(root[\"clappr\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_5__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"<%=baseUrl%>/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if(\"value\"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _clappr=__webpack_require__(5);var _clappr2=_interopRequireDefault(_clappr);var _mousetrap=__webpack_require__(4);var _mousetrap2=_interopRequireDefault(_mousetrap);var _view=__webpack_require__(3);var _view2=_interopRequireDefault(_view);var _style=__webpack_require__(1);var _style2=_interopRequireDefault(_style);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");}return call&&(typeof call===\"object\"||typeof call===\"function\")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!==\"function\"&&superClass!==null){throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/* global PLUGIN_VERSION */// node\n\t// vendors\n\t// project\n\t// locals\n\tvar SCALE_FRAMES='frames';var SCALE_SECONDS='seconds';var BUTTON_STATE_DOWN='down';var BUTTON_STATE_UP='up';var FPS_DEFAULT=29;var PlaybackControl=function(_Clappr$UICorePlugin){_inherits(PlaybackControl,_Clappr$UICorePlugin);function PlaybackControl(){_classCallCheck(this,PlaybackControl);return _possibleConstructorReturn(this,Object.getPrototypeOf(PlaybackControl).apply(this,arguments));}_createClass(PlaybackControl,[{key:'onContainerChanged',// methods\n\tvalue:function onContainerChanged(){this.invalidate();}},{key:'seekScaleValue',value:function seekScaleValue(scale,value){switch(scale){case SCALE_FRAMES:this.seekRelativeFrames(value);break;case SCALE_SECONDS:this.seekRelativeSeconds(value);break;default:break;}}},{key:'findButton',value:function findButton(scale,value){var signed=value>0?'+'+value:value;return this.$el.find('[data-step-scale=\"'+scale+'\"][data-step-value=\"'+signed+'\"]');}},{key:'highlightButton',value:function highlightButton(scale,value,state){var button=this.findButton(scale,value);switch(state){case BUTTON_STATE_DOWN:button.children()[1].className='playback-control-action-highlight';break;case BUTTON_STATE_UP:button.children()[1].className='';break;default:break;}return button;}},{key:'onButtonClick',value:function onButtonClick(e){var sender=e.currentTarget;var scale=sender.getAttribute('data-step-scale');var value=Number(sender.getAttribute('data-step-value'));// control player\n\tthis.seekScaleValue(scale,value);}},{key:'onActionsMouseWheel',value:function onActionsMouseWheel(e){var sender=e.currentTarget;var scale=sender.getAttribute('data-step-scale');var value=e.detail<0||e.wheelDelta>0?1:-1;this.seekScaleValue(scale,value);e.stopPropagation();e.preventDefault();return false;}},{key:'bindEvents',value:function bindEvents(){var _this2=this;// const config = this.config;\n\tvar player=this.player;this.listenTo(this.mediaControl,_clappr2.default.Events.MEDIACONTROL_RENDERED,this.render);this.listenTo(this.mediaControl,_clappr2.default.Events.MEDIACONTROL_CONTAINERCHANGED,this.onContainerChanged);// non-clappr events\n\t_mousetrap2.default.addKeycodes({144:'numlock'});// standard keyboard shortcuts\n\t_mousetrap2.default.bind('q',function(){return _this2.highlightButton(SCALE_SECONDS,-1,BUTTON_STATE_DOWN);},'keydown');_mousetrap2.default.bind('q',function(){_this2.highlightButton(SCALE_SECONDS,-1,BUTTON_STATE_UP);_this2.seekRelativeSeconds(-1);},'keyup');_mousetrap2.default.bind('w',function(){return _this2.highlightButton(SCALE_SECONDS,+1,BUTTON_STATE_DOWN);},'keydown');_mousetrap2.default.bind('w',function(){_this2.highlightButton(SCALE_SECONDS,+1,BUTTON_STATE_UP);_this2.seekRelativeSeconds(+1);},'keyup');_mousetrap2.default.bind('a',function(){return _this2.highlightButton(SCALE_FRAMES,-1,BUTTON_STATE_DOWN);},'keydown');_mousetrap2.default.bind('a',function(){_this2.highlightButton(SCALE_FRAMES,-1,BUTTON_STATE_UP);_this2.seekRelativeFrames(-1);},'keyup');_mousetrap2.default.bind('s',function(){return _this2.highlightButton(SCALE_FRAMES,+1,BUTTON_STATE_DOWN);},'keydown');_mousetrap2.default.bind('s',function(){_this2.highlightButton(SCALE_FRAMES,+1,BUTTON_STATE_UP);_this2.seekRelativeFrames(+1);},'keyup');_mousetrap2.default.bind('space',function(){if(player.isPlaying()){player.pause();}else{player.play();}});// shuttle xpress - large wheel with arrow keys fallback(time control)\n\t_mousetrap2.default.bind('up',function(){return _this2.seekRelativeSeconds(-1);});_mousetrap2.default.bind('down',function(){return _this2.seekRelativeSeconds(+1);});// shuttle xpress - small wheel with arrow keys fallback(time control)\n\t_mousetrap2.default.bind('left',function(){return _this2.seekRelativeFrames(-1);});_mousetrap2.default.bind('right',function(){return _this2.seekRelativeFrames(+1);});// shuttle xpress - small wheel with ctrl +/- keys combo fallback(frame control)\n\t_mousetrap2.default.bind('ctrl+-',function(e){e.preventDefault();e.stopPropagation();_this2.seekRelativeFrames(-1);});_mousetrap2.default.bind(['ctrl+=','ctrl+plus'],function(e){e.preventDefault();e.stopPropagation();_this2.seekRelativeFrames(+1);});// shuttle express - buttons(numeric keys fallback)\n\tvar switchPlaybackRate=function switchPlaybackRate(e,rate){e.preventDefault();e.stopPropagation();_this2.mediaControl.trigger('playbackRate',rate);return false;};_mousetrap2.default.bind('0',function(e){return switchPlaybackRate(e,0.5);});_mousetrap2.default.bind(['1','numlock+alt+left'],function(e){return switchPlaybackRate(e,1);});_mousetrap2.default.bind(['2','numlock+ctrl+h'],function(e){return switchPlaybackRate(e,2);});_mousetrap2.default.bind(['3','ctrl+shift+o','numlock+ctrl+i'],function(e){return switchPlaybackRate(e,3);});_mousetrap2.default.bind(['4','numlock+ctrl+t'],function(e){return switchPlaybackRate(e,4);});_mousetrap2.default.bind(['5','numlock+alt+right'],function(e){return switchPlaybackRate(e,5);});_mousetrap2.default.bind('6',function(e){return switchPlaybackRate(e,6);});_mousetrap2.default.bind('7',function(e){return switchPlaybackRate(e,7);});_mousetrap2.default.bind('8',function(e){return switchPlaybackRate(e,8);});_mousetrap2.default.bind('9',function(e){return switchPlaybackRate(e,9);});}},{key:'stopListening',value:function stopListening(){_get(Object.getPrototypeOf(PlaybackControl.prototype),'stopListening',this).call(this);// non-clappr events\n\tif(this.onMouseWheelDelegate){this.onMouseWheelDelegate.unbind();this.onMouseWheelDelegate=null;}}},{key:'render',value:function render(){var style=_clappr2.default.Styler.getStyleFor(_style2.default);this.$el.html(this.template()).append(style);this.$el.find('[type=\"button\"]').off('click').on('click',this.onButtonClick.bind(this));this.$el.find('.playback-control-actions').off('DOMMouseScroll').on('DOMMouseScroll',this.onActionsMouseWheel.bind(this));this.$el.find('.playback-control-actions').off('mousewheel').on('mousewheel',this.onActionsMouseWheel.bind(this));this.mediaControl.$('.media-control-left-panel[data-media-control]').append(this.el);return this;}},{key:'invalidate',value:function invalidate(){this.stopListening();this.bindEvents();}},{key:'getFPS',value:function getFPS(){var fps=FPS_DEFAULT;if(this.player&&this.player.options&&this.player.options.playbackControl){fps=this.player.options.playbackControl.fps||fps;}return fps;}},{key:'seekRelativeFrames',value:function seekRelativeFrames(frames){var player=this.player;if(player.isPlaying()){player.pause();}var currentTime=player.getCurrentTime();var targetTime=currentTime+frames/this.getFPS();if(targetTime<=0||targetTime>=player.getDuration()){// TODO: decide on how to norm bounds\n\t}else{var playback=this.core.getCurrentPlayback();player.seek(targetTime);// Trigger the waiting event that will buffer the video if targetTime is not buffered yet\n\tvar bufferedTimeRange=playback.el.buffered;var targetFrameBuffered=false;for(var i=0;i<bufferedTimeRange.length;i++){if(targetTime>=bufferedTimeRange.start(i)&&targetTime<=bufferedTimeRange.end(i)){targetFrameBuffered=true;break;}}if(!targetFrameBuffered){playback.trigger('waiting');}}}},{key:'seekRelativeSeconds',value:function seekRelativeSeconds(seconds){var player=this.player;if(player.isPlaying()){player.pause();}var position=player.getCurrentTime()+seconds;if(position<0){position=0;}else if(position>player.getDuration()){position=player.getDuration();}player.seek(position);}},{key:'name',// properties\n\tget:function get(){return'playback_control';}},{key:'version',get:function get(){return PLUGIN_VERSION;}},{key:'template',get:function get(){return _clappr2.default.template(_view2.default);}},{key:'attributes',get:function get(){return{class:'playback-control'};}},{key:'mediaControl',get:function get(){return this.core.mediaControl;}},{key:'player',get:function get(){return this.mediaControl.container;}},{key:'config',get:function get(){return this.core.options.playbackControlConfig||{keyBindings:[]};}}]);return PlaybackControl;}(_clappr2.default.UICorePlugin);exports.default=PlaybackControl;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(2)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"[data-player] div.playback-control{float:left}[data-player] div.playback-control>.playback-control-actions{display:inline-block;margin-left:1px;margin-right:1px;height:28px}[data-player] div.playback-control>.playback-control-actions:hover{background:#eee}[data-player] div.playback-control>.playback-control-actions>button{outline:none;cursor:pointer;border:1px solid #444;margin:1px;text-align:center;width:35px;height:26px}[data-player] div.playback-control>.playback-control-actions>button>sub{outline:none;position:relative;display:inline-block;background:#eee;border-radius:15px;width:25px;border:1px solid;left:-2px;bottom:0;font-weight:700;font-family:Consolas,Lucida Console,Monaco,monospace;font-size:11px}[data-player] div.playback-control>.playback-control-actions>button>sub.playback-control-action-highlight{background:#febf04;border-color:#333;color:#333;position:relative;top:1px;left:1px}[data-player] div.playback-control>.playback-control-actions>button:hover{background:#333;color:#eee}[data-player] div.playback-control>.playback-control-actions>button:hover>sub{border-color:#eee;color:#333}[data-player] div.playback-control>.playback-control-actions>button:active{background:#666;color:#333;border-color:#111;position:relative;top:1px}[data-player] div.playback-control>.playback-control-actions>button:active>sub{background:#111;color:#666;border-color:#111;font-weight:700}[data-player] div.playback-control>.playback-control-actions>button::-moz-focus-inner{border:0}[data-player] div.playback-control>.playback-control-actions[data-step-scale=seconds]>button{background:#00b7ea}[data-player] div.playback-control>.playback-control-actions[data-step-scale=frames]>button{background:#d2ff52}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"seconds\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second backward\\\">\\n    <p>-1</p>\\n    <sub>Q</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second forward\\\">\\n    <p>+1</p>\\n    <sub>W</sub>\\n  </button>\\n</div>\\n<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"frames\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame backward\\\">\\n    <p>-1</p>\\n    <sub>A</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame forward\\\">\\n    <p>+1</p>\\n    <sub>S</sub>\\n  </button>\\n</div>\\n\";\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*global define:false */\n\t/**\n\t * Copyright 2016 Craig Campbell\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * Mousetrap is a simple keyboard shortcut library for Javascript with\n\t * no external dependencies\n\t *\n\t * @version 1.6.0\n\t * @url craig.is/killing/mice\n\t */\n\t(function(window, document, undefined) {\n\t\n\t    // Check if mousetrap is used inside browser, if not, return\n\t    if (!window) {\n\t        return;\n\t    }\n\t\n\t    /**\n\t     * mapping of special keycodes to their corresponding keys\n\t     *\n\t     * everything in this dictionary cannot use keypress events\n\t     * so it has to be here to map to the correct keycodes for\n\t     * keyup/keydown events\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _MAP = {\n\t        8: 'backspace',\n\t        9: 'tab',\n\t        13: 'enter',\n\t        16: 'shift',\n\t        17: 'ctrl',\n\t        18: 'alt',\n\t        20: 'capslock',\n\t        27: 'esc',\n\t        32: 'space',\n\t        33: 'pageup',\n\t        34: 'pagedown',\n\t        35: 'end',\n\t        36: 'home',\n\t        37: 'left',\n\t        38: 'up',\n\t        39: 'right',\n\t        40: 'down',\n\t        45: 'ins',\n\t        46: 'del',\n\t        91: 'meta',\n\t        93: 'meta',\n\t        224: 'meta'\n\t    };\n\t\n\t    /**\n\t     * mapping for special characters so they can support\n\t     *\n\t     * this dictionary is only used incase you want to bind a\n\t     * keyup or keydown event to one of these keys\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _KEYCODE_MAP = {\n\t        106: '*',\n\t        107: '+',\n\t        109: '-',\n\t        110: '.',\n\t        111 : '/',\n\t        186: ';',\n\t        187: '=',\n\t        188: ',',\n\t        189: '-',\n\t        190: '.',\n\t        191: '/',\n\t        192: '`',\n\t        219: '[',\n\t        220: '\\\\',\n\t        221: ']',\n\t        222: '\\''\n\t    };\n\t\n\t    /**\n\t     * this is a mapping of keys that require shift on a US keypad\n\t     * back to the non shift equivelents\n\t     *\n\t     * this is so you can use keyup events with these keys\n\t     *\n\t     * note that this will only work reliably on US keyboards\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SHIFT_MAP = {\n\t        '~': '`',\n\t        '!': '1',\n\t        '@': '2',\n\t        '#': '3',\n\t        '$': '4',\n\t        '%': '5',\n\t        '^': '6',\n\t        '&': '7',\n\t        '*': '8',\n\t        '(': '9',\n\t        ')': '0',\n\t        '_': '-',\n\t        '+': '=',\n\t        ':': ';',\n\t        '\\\"': '\\'',\n\t        '<': ',',\n\t        '>': '.',\n\t        '?': '/',\n\t        '|': '\\\\'\n\t    };\n\t\n\t    /**\n\t     * this is a list of special strings you can use to map\n\t     * to modifier keys when you specify your keyboard shortcuts\n\t     *\n\t     * @type {Object}\n\t     */\n\t    var _SPECIAL_ALIASES = {\n\t        'option': 'alt',\n\t        'command': 'meta',\n\t        'return': 'enter',\n\t        'escape': 'esc',\n\t        'plus': '+',\n\t        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n\t    };\n\t\n\t    /**\n\t     * variable to store the flipped version of _MAP from above\n\t     * needed to check if we should use keypress or not when no action\n\t     * is specified\n\t     *\n\t     * @type {Object|undefined}\n\t     */\n\t    var _REVERSE_MAP;\n\t\n\t    /**\n\t     * loop through the f keys, f1 to f19 and add them to the map\n\t     * programatically\n\t     */\n\t    for (var i = 1; i < 20; ++i) {\n\t        _MAP[111 + i] = 'f' + i;\n\t    }\n\t\n\t    /**\n\t     * loop through to map numbers on the numeric keypad\n\t     */\n\t    for (i = 0; i <= 9; ++i) {\n\t        _MAP[i + 96] = i;\n\t    }\n\t\n\t    /**\n\t     * cross browser add event method\n\t     *\n\t     * @param {Element|HTMLDocument} object\n\t     * @param {string} type\n\t     * @param {Function} callback\n\t     * @returns void\n\t     */\n\t    function _addEvent(object, type, callback) {\n\t        if (object.addEventListener) {\n\t            object.addEventListener(type, callback, false);\n\t            return;\n\t        }\n\t\n\t        object.attachEvent('on' + type, callback);\n\t    }\n\t\n\t    /**\n\t     * takes the event and returns the key character\n\t     *\n\t     * @param {Event} e\n\t     * @return {string}\n\t     */\n\t    function _characterFromEvent(e) {\n\t\n\t        // for keypress events we should return the character as is\n\t        if (e.type == 'keypress') {\n\t            var character = String.fromCharCode(e.which);\n\t\n\t            // if the shift key is not pressed then it is safe to assume\n\t            // that we want the character to be lowercase.  this means if\n\t            // you accidentally have caps lock on then your key bindings\n\t            // will continue to work\n\t            //\n\t            // the only side effect that might not be desired is if you\n\t            // bind something like 'A' cause you want to trigger an\n\t            // event when capital A is pressed caps lock will no longer\n\t            // trigger the event.  shift+a will though.\n\t            if (!e.shiftKey) {\n\t                character = character.toLowerCase();\n\t            }\n\t\n\t            return character;\n\t        }\n\t\n\t        // for non keypress events the special maps are needed\n\t        if (_MAP[e.which]) {\n\t            return _MAP[e.which];\n\t        }\n\t\n\t        if (_KEYCODE_MAP[e.which]) {\n\t            return _KEYCODE_MAP[e.which];\n\t        }\n\t\n\t        // if it is not in the special map\n\t\n\t        // with keydown and keyup events the character seems to always\n\t        // come in as an uppercase character whether you are pressing shift\n\t        // or not.  we should make sure it is always lowercase for comparisons\n\t        return String.fromCharCode(e.which).toLowerCase();\n\t    }\n\t\n\t    /**\n\t     * checks if two arrays are equal\n\t     *\n\t     * @param {Array} modifiers1\n\t     * @param {Array} modifiers2\n\t     * @returns {boolean}\n\t     */\n\t    function _modifiersMatch(modifiers1, modifiers2) {\n\t        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n\t    }\n\t\n\t    /**\n\t     * takes a key event and figures out what the modifiers are\n\t     *\n\t     * @param {Event} e\n\t     * @returns {Array}\n\t     */\n\t    function _eventModifiers(e) {\n\t        var modifiers = [];\n\t\n\t        if (e.shiftKey) {\n\t            modifiers.push('shift');\n\t        }\n\t\n\t        if (e.altKey) {\n\t            modifiers.push('alt');\n\t        }\n\t\n\t        if (e.ctrlKey) {\n\t            modifiers.push('ctrl');\n\t        }\n\t\n\t        if (e.metaKey) {\n\t            modifiers.push('meta');\n\t        }\n\t\n\t        return modifiers;\n\t    }\n\t\n\t    /**\n\t     * prevents default for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _preventDefault(e) {\n\t        if (e.preventDefault) {\n\t            e.preventDefault();\n\t            return;\n\t        }\n\t\n\t        e.returnValue = false;\n\t    }\n\t\n\t    /**\n\t     * stops propogation for this event\n\t     *\n\t     * @param {Event} e\n\t     * @returns void\n\t     */\n\t    function _stopPropagation(e) {\n\t        if (e.stopPropagation) {\n\t            e.stopPropagation();\n\t            return;\n\t        }\n\t\n\t        e.cancelBubble = true;\n\t    }\n\t\n\t    /**\n\t     * determines if the keycode specified is a modifier key or not\n\t     *\n\t     * @param {string} key\n\t     * @returns {boolean}\n\t     */\n\t    function _isModifier(key) {\n\t        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n\t    }\n\t\n\t    /**\n\t     * reverses the map lookup so that we can look for specific keys\n\t     * to see what can and can't use keypress\n\t     *\n\t     * @return {Object}\n\t     */\n\t    function _getReverseMap() {\n\t        if (!_REVERSE_MAP) {\n\t            _REVERSE_MAP = {};\n\t            for (var key in _MAP) {\n\t\n\t                // pull out the numeric keypad from here cause keypress should\n\t                // be able to detect the keys from the character\n\t                if (key > 95 && key < 112) {\n\t                    continue;\n\t                }\n\t\n\t                if (_MAP.hasOwnProperty(key)) {\n\t                    _REVERSE_MAP[_MAP[key]] = key;\n\t                }\n\t            }\n\t        }\n\t        return _REVERSE_MAP;\n\t    }\n\t\n\t    /**\n\t     * picks the best action based on the key combination\n\t     *\n\t     * @param {string} key - character for key\n\t     * @param {Array} modifiers\n\t     * @param {string=} action passed in\n\t     */\n\t    function _pickBestAction(key, modifiers, action) {\n\t\n\t        // if no action was picked in we should try to pick the one\n\t        // that we think would work best for this key\n\t        if (!action) {\n\t            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n\t        }\n\t\n\t        // modifier keys don't work as expected with keypress,\n\t        // switch to keydown\n\t        if (action == 'keypress' && modifiers.length) {\n\t            action = 'keydown';\n\t        }\n\t\n\t        return action;\n\t    }\n\t\n\t    /**\n\t     * Converts from a string key combination to an array\n\t     *\n\t     * @param  {string} combination like \"command+shift+l\"\n\t     * @return {Array}\n\t     */\n\t    function _keysFromString(combination) {\n\t        if (combination === '+') {\n\t            return ['+'];\n\t        }\n\t\n\t        combination = combination.replace(/\\+{2}/g, '+plus');\n\t        return combination.split('+');\n\t    }\n\t\n\t    /**\n\t     * Gets info for a specific key combination\n\t     *\n\t     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n\t     * @param  {string=} action\n\t     * @returns {Object}\n\t     */\n\t    function _getKeyInfo(combination, action) {\n\t        var keys;\n\t        var key;\n\t        var i;\n\t        var modifiers = [];\n\t\n\t        // take the keys from this pattern and figure out what the actual\n\t        // pattern is all about\n\t        keys = _keysFromString(combination);\n\t\n\t        for (i = 0; i < keys.length; ++i) {\n\t            key = keys[i];\n\t\n\t            // normalize key names\n\t            if (_SPECIAL_ALIASES[key]) {\n\t                key = _SPECIAL_ALIASES[key];\n\t            }\n\t\n\t            // if this is not a keypress event then we should\n\t            // be smart about using shift keys\n\t            // this will only work for US keyboards however\n\t            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n\t                key = _SHIFT_MAP[key];\n\t                modifiers.push('shift');\n\t            }\n\t\n\t            // if this key is a modifier then add it to the list of modifiers\n\t            if (_isModifier(key)) {\n\t                modifiers.push(key);\n\t            }\n\t        }\n\t\n\t        // depending on what the key combination is\n\t        // we will try to pick the best event for it\n\t        action = _pickBestAction(key, modifiers, action);\n\t\n\t        return {\n\t            key: key,\n\t            modifiers: modifiers,\n\t            action: action\n\t        };\n\t    }\n\t\n\t    function _belongsTo(element, ancestor) {\n\t        if (element === null || element === document) {\n\t            return false;\n\t        }\n\t\n\t        if (element === ancestor) {\n\t            return true;\n\t        }\n\t\n\t        return _belongsTo(element.parentNode, ancestor);\n\t    }\n\t\n\t    function Mousetrap(targetElement) {\n\t        var self = this;\n\t\n\t        targetElement = targetElement || document;\n\t\n\t        if (!(self instanceof Mousetrap)) {\n\t            return new Mousetrap(targetElement);\n\t        }\n\t\n\t        /**\n\t         * element to attach key events to\n\t         *\n\t         * @type {Element}\n\t         */\n\t        self.target = targetElement;\n\t\n\t        /**\n\t         * a list of all the callbacks setup via Mousetrap.bind()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._callbacks = {};\n\t\n\t        /**\n\t         * direct map of string combinations to callbacks used for trigger()\n\t         *\n\t         * @type {Object}\n\t         */\n\t        self._directMap = {};\n\t\n\t        /**\n\t         * keeps track of what level each sequence is at since multiple\n\t         * sequences can start out with the same sequence\n\t         *\n\t         * @type {Object}\n\t         */\n\t        var _sequenceLevels = {};\n\t\n\t        /**\n\t         * variable to store the setTimeout call\n\t         *\n\t         * @type {null|number}\n\t         */\n\t        var _resetTimer;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keyup\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _ignoreNextKeyup = false;\n\t\n\t        /**\n\t         * temporary state where we will ignore the next keypress\n\t         *\n\t         * @type {boolean}\n\t         */\n\t        var _ignoreNextKeypress = false;\n\t\n\t        /**\n\t         * are we currently inside of a sequence?\n\t         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n\t         *\n\t         * @type {boolean|string}\n\t         */\n\t        var _nextExpectedAction = false;\n\t\n\t        /**\n\t         * resets all sequence counters except for the ones passed in\n\t         *\n\t         * @param {Object} doNotReset\n\t         * @returns void\n\t         */\n\t        function _resetSequences(doNotReset) {\n\t            doNotReset = doNotReset || {};\n\t\n\t            var activeSequences = false,\n\t                key;\n\t\n\t            for (key in _sequenceLevels) {\n\t                if (doNotReset[key]) {\n\t                    activeSequences = true;\n\t                    continue;\n\t                }\n\t                _sequenceLevels[key] = 0;\n\t            }\n\t\n\t            if (!activeSequences) {\n\t                _nextExpectedAction = false;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * finds all callbacks that match based on the keycode, modifiers,\n\t         * and action\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event|Object} e\n\t         * @param {string=} sequenceName - name of the sequence we are looking for\n\t         * @param {string=} combination\n\t         * @param {number=} level\n\t         * @returns {Array}\n\t         */\n\t        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n\t            var i;\n\t            var callback;\n\t            var matches = [];\n\t            var action = e.type;\n\t\n\t            // if there are no events related to this keycode\n\t            if (!self._callbacks[character]) {\n\t                return [];\n\t            }\n\t\n\t            // if a modifier key is coming up on its own we should allow it\n\t            if (action == 'keyup' && _isModifier(character)) {\n\t                modifiers = [character];\n\t            }\n\t\n\t            // loop through all callbacks for the key that was pressed\n\t            // and see if any of them match\n\t            for (i = 0; i < self._callbacks[character].length; ++i) {\n\t                callback = self._callbacks[character][i];\n\t\n\t                // if a sequence name is not specified, but this is a sequence at\n\t                // the wrong level then move onto the next match\n\t                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n\t                    continue;\n\t                }\n\t\n\t                // if the action we are looking for doesn't match the action we got\n\t                // then we should keep going\n\t                if (action != callback.action) {\n\t                    continue;\n\t                }\n\t\n\t                // if this is a keypress event and the meta key and control key\n\t                // are not pressed that means that we need to only look at the\n\t                // character, otherwise check the modifiers as well\n\t                //\n\t                // chrome will not fire a keypress if meta or control is down\n\t                // safari will fire a keypress if meta or meta+shift is down\n\t                // firefox will fire a keypress if meta or control is down\n\t                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\t\n\t                    // when you bind a combination or sequence a second time it\n\t                    // should overwrite the first one.  if a sequenceName or\n\t                    // combination is specified in this call it does just that\n\t                    //\n\t                    // @todo make deleting its own method?\n\t                    var deleteCombo = !sequenceName && callback.combo == combination;\n\t                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\t                    if (deleteCombo || deleteSequence) {\n\t                        self._callbacks[character].splice(i, 1);\n\t                    }\n\t\n\t                    matches.push(callback);\n\t                }\n\t            }\n\t\n\t            return matches;\n\t        }\n\t\n\t        /**\n\t         * actually calls the callback function\n\t         *\n\t         * if your callback function returns false this will use the jquery\n\t         * convention - prevent default and stop propogation on the event\n\t         *\n\t         * @param {Function} callback\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _fireCallback(callback, e, combo, sequence) {\n\t\n\t            // if this event should not happen stop here\n\t            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n\t                return;\n\t            }\n\t\n\t            if (callback(e, combo) === false) {\n\t                _preventDefault(e);\n\t                _stopPropagation(e);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * handles a character key event\n\t         *\n\t         * @param {string} character\n\t         * @param {Array} modifiers\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        self._handleKey = function(character, modifiers, e) {\n\t            var callbacks = _getMatches(character, modifiers, e);\n\t            var i;\n\t            var doNotReset = {};\n\t            var maxLevel = 0;\n\t            var processedSequenceCallback = false;\n\t\n\t            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t                if (callbacks[i].seq) {\n\t                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n\t                }\n\t            }\n\t\n\t            // loop through matching callbacks for this key event\n\t            for (i = 0; i < callbacks.length; ++i) {\n\t\n\t                // fire for all sequence callbacks\n\t                // this is because if for example you have multiple sequences\n\t                // bound such as \"g i\" and \"g t\" they both need to fire the\n\t                // callback for matching g cause otherwise you can only ever\n\t                // match the first one\n\t                if (callbacks[i].seq) {\n\t\n\t                    // only fire callbacks for the maxLevel to prevent\n\t                    // subsequences from also firing\n\t                    //\n\t                    // for example 'a option b' should not cause 'option b' to fire\n\t                    // even though 'option b' is part of the other sequence\n\t                    //\n\t                    // any sequences that do not match here will be discarded\n\t                    // below by the _resetSequences call\n\t                    if (callbacks[i].level != maxLevel) {\n\t                        continue;\n\t                    }\n\t\n\t                    processedSequenceCallback = true;\n\t\n\t                    // keep a list of which sequences were matches for later\n\t                    doNotReset[callbacks[i].seq] = 1;\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\t                    continue;\n\t                }\n\t\n\t                // if there were no sequence matches but we are still here\n\t                // that means this is a regular match so we should fire that\n\t                if (!processedSequenceCallback) {\n\t                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n\t                }\n\t            }\n\t\n\t            // if the key you pressed matches the type of sequence without\n\t            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n\t            // reset all sequences that were not matched by this event\n\t            //\n\t            // this is so, for example, if you have the sequence \"h a t\" and you\n\t            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n\t            // cause the sequence to reset\n\t            //\n\t            // modifier keys are ignored because you can have a sequence\n\t            // that contains modifiers such as \"enter ctrl+space\" and in most\n\t            // cases the modifier key will be pressed before the next key\n\t            //\n\t            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n\t            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n\t            //\n\t            // the \"keydown\" is expected when there is a modifier, but the\n\t            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n\t            // after and that causes the sequence to reset\n\t            //\n\t            // we ignore keypresses in a sequence that directly follow a keydown\n\t            // for the same character\n\t            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\t            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n\t                _resetSequences(doNotReset);\n\t            }\n\t\n\t            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n\t        };\n\t\n\t        /**\n\t         * handles a keydown event\n\t         *\n\t         * @param {Event} e\n\t         * @returns void\n\t         */\n\t        function _handleKeyEvent(e) {\n\t\n\t            // normalize e.which for key events\n\t            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n\t            if (typeof e.which !== 'number') {\n\t                e.which = e.keyCode;\n\t            }\n\t\n\t            var character = _characterFromEvent(e);\n\t\n\t            // no character found then stop\n\t            if (!character) {\n\t                return;\n\t            }\n\t\n\t            // need to use === for the character check because the character can be 0\n\t            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n\t                _ignoreNextKeyup = false;\n\t                return;\n\t            }\n\t\n\t            self.handleKey(character, _eventModifiers(e), e);\n\t        }\n\t\n\t        /**\n\t         * called to set a 1 second timeout on the specified sequence\n\t         *\n\t         * this is so after each key press in the sequence you have 1 second\n\t         * to press the next key before you have to start over\n\t         *\n\t         * @returns void\n\t         */\n\t        function _resetSequenceTimer() {\n\t            clearTimeout(_resetTimer);\n\t            _resetTimer = setTimeout(_resetSequences, 1000);\n\t        }\n\t\n\t        /**\n\t         * binds a key sequence to an event\n\t         *\n\t         * @param {string} combo - combo specified in bind call\n\t         * @param {Array} keys\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @returns void\n\t         */\n\t        function _bindSequence(combo, keys, callback, action) {\n\t\n\t            // start off by adding a sequence level record for this combination\n\t            // and setting the level to 0\n\t            _sequenceLevels[combo] = 0;\n\t\n\t            /**\n\t             * callback to increase the sequence level for this sequence and reset\n\t             * all other sequences that were active\n\t             *\n\t             * @param {string} nextAction\n\t             * @returns {Function}\n\t             */\n\t            function _increaseSequence(nextAction) {\n\t                return function() {\n\t                    _nextExpectedAction = nextAction;\n\t                    ++_sequenceLevels[combo];\n\t                    _resetSequenceTimer();\n\t                };\n\t            }\n\t\n\t            /**\n\t             * wraps the specified callback inside of another function in order\n\t             * to reset all sequence counters as soon as this sequence is done\n\t             *\n\t             * @param {Event} e\n\t             * @returns void\n\t             */\n\t            function _callbackAndReset(e) {\n\t                _fireCallback(callback, e, combo);\n\t\n\t                // we should ignore the next key up if the action is key down\n\t                // or keypress.  this is so if you finish a sequence and\n\t                // release the key the final key will not trigger a keyup\n\t                if (action !== 'keyup') {\n\t                    _ignoreNextKeyup = _characterFromEvent(e);\n\t                }\n\t\n\t                // weird race condition if a sequence ends with the key\n\t                // another sequence begins with\n\t                setTimeout(_resetSequences, 10);\n\t            }\n\t\n\t            // loop through keys one at a time and bind the appropriate callback\n\t            // function.  for any key leading up to the final one it should\n\t            // increase the sequence. after the final, it should reset all sequences\n\t            //\n\t            // if an action is specified in the original bind call then that will\n\t            // be used throughout.  otherwise we will pass the action that the\n\t            // next key in the sequence should match.  this allows a sequence\n\t            // to mix and match keypress and keydown events depending on which\n\t            // ones are better suited to the key provided\n\t            for (var i = 0; i < keys.length; ++i) {\n\t                var isFinal = i + 1 === keys.length;\n\t                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\t                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * binds a single keyboard combination\n\t         *\n\t         * @param {string} combination\n\t         * @param {Function} callback\n\t         * @param {string=} action\n\t         * @param {string=} sequenceName - name of sequence if part of sequence\n\t         * @param {number=} level - what part of the sequence the command is\n\t         * @returns void\n\t         */\n\t        function _bindSingle(combination, callback, action, sequenceName, level) {\n\t\n\t            // store a direct mapped reference for use with Mousetrap.trigger\n\t            self._directMap[combination + ':' + action] = callback;\n\t\n\t            // make sure multiple spaces in a row become a single space\n\t            combination = combination.replace(/\\s+/g, ' ');\n\t\n\t            var sequence = combination.split(' ');\n\t            var info;\n\t\n\t            // if this pattern is a sequence of keys then run through this method\n\t            // to reprocess each pattern one key at a time\n\t            if (sequence.length > 1) {\n\t                _bindSequence(combination, sequence, callback, action);\n\t                return;\n\t            }\n\t\n\t            info = _getKeyInfo(combination, action);\n\t\n\t            // make sure to initialize array if this is the first time\n\t            // a callback is added for this key\n\t            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\t\n\t            // remove an existing match if there is one\n\t            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\t\n\t            // add this call back to the array\n\t            // if it is a sequence put it at the beginning\n\t            // if not put it at the end\n\t            //\n\t            // this is important because the way these are processed expects\n\t            // the sequence ones to come first\n\t            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n\t                callback: callback,\n\t                modifiers: info.modifiers,\n\t                action: info.action,\n\t                seq: sequenceName,\n\t                level: level,\n\t                combo: combination\n\t            });\n\t        }\n\t\n\t        /**\n\t         * binds multiple combinations to the same callback\n\t         *\n\t         * @param {Array} combinations\n\t         * @param {Function} callback\n\t         * @param {string|undefined} action\n\t         * @returns void\n\t         */\n\t        self._bindMultiple = function(combinations, callback, action) {\n\t            for (var i = 0; i < combinations.length; ++i) {\n\t                _bindSingle(combinations[i], callback, action);\n\t            }\n\t        };\n\t\n\t        // start!\n\t        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n\t        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n\t    }\n\t\n\t    /**\n\t     * binds an event to mousetrap\n\t     *\n\t     * can be a single key, a combination of keys separated with +,\n\t     * an array of keys, or a sequence of keys separated by spaces\n\t     *\n\t     * be sure to list the modifier keys first to make sure that the\n\t     * correct key ends up getting bound (the last key in the pattern)\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {Function} callback\n\t     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.bind = function(keys, callback, action) {\n\t        var self = this;\n\t        keys = keys instanceof Array ? keys : [keys];\n\t        self._bindMultiple.call(self, keys, callback, action);\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * unbinds an event to mousetrap\n\t     *\n\t     * the unbinding sets the callback function of the specified key combo\n\t     * to an empty function and deletes the corresponding key in the\n\t     * _directMap dict.\n\t     *\n\t     * TODO: actually remove this from the _callbacks dictionary instead\n\t     * of binding an empty function\n\t     *\n\t     * the keycombo+action has to be exactly the same as\n\t     * it was defined in the bind method\n\t     *\n\t     * @param {string|Array} keys\n\t     * @param {string} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.unbind = function(keys, action) {\n\t        var self = this;\n\t        return self.bind.call(self, keys, function() {}, action);\n\t    };\n\t\n\t    /**\n\t     * triggers an event that has already been bound\n\t     *\n\t     * @param {string} keys\n\t     * @param {string=} action\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.trigger = function(keys, action) {\n\t        var self = this;\n\t        if (self._directMap[keys + ':' + action]) {\n\t            self._directMap[keys + ':' + action]({}, keys);\n\t        }\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * resets the library back to its initial state.  this is useful\n\t     * if you want to clear out the current keyboard shortcuts and bind\n\t     * new ones - for example if you switch to another page\n\t     *\n\t     * @returns void\n\t     */\n\t    Mousetrap.prototype.reset = function() {\n\t        var self = this;\n\t        self._callbacks = {};\n\t        self._directMap = {};\n\t        return self;\n\t    };\n\t\n\t    /**\n\t     * should we stop this event before firing off callbacks\n\t     *\n\t     * @param {Event} e\n\t     * @param {Element} element\n\t     * @return {boolean}\n\t     */\n\t    Mousetrap.prototype.stopCallback = function(e, element) {\n\t        var self = this;\n\t\n\t        // if the element has the class \"mousetrap\" then no need to stop\n\t        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n\t            return false;\n\t        }\n\t\n\t        if (_belongsTo(element, self.target)) {\n\t            return false;\n\t        }\n\t\n\t        // stop for input, select, and textarea\n\t        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n\t    };\n\t\n\t    /**\n\t     * exposes _handleKey publicly so it can be overwritten by extensions\n\t     */\n\t    Mousetrap.prototype.handleKey = function() {\n\t        var self = this;\n\t        return self._handleKey.apply(self, arguments);\n\t    };\n\t\n\t    /**\n\t     * allow custom key mappings\n\t     */\n\t    Mousetrap.addKeycodes = function(object) {\n\t        for (var key in object) {\n\t            if (object.hasOwnProperty(key)) {\n\t                _MAP[key] = object[key];\n\t            }\n\t        }\n\t        _REVERSE_MAP = null;\n\t    };\n\t\n\t    /**\n\t     * Init the global mousetrap functions\n\t     *\n\t     * This method is needed to allow the global mousetrap functions to work\n\t     * now that mousetrap is a constructor function.\n\t     */\n\t    Mousetrap.init = function() {\n\t        var documentMousetrap = Mousetrap(document);\n\t        for (var method in documentMousetrap) {\n\t            if (method.charAt(0) !== '_') {\n\t                Mousetrap[method] = (function(method) {\n\t                    return function() {\n\t                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n\t                    };\n\t                } (method));\n\t            }\n\t        }\n\t    };\n\t\n\t    Mousetrap.init();\n\t\n\t    // expose mousetrap to the global object\n\t    window.Mousetrap = Mousetrap;\n\t\n\t    // expose as a common js module\n\t    if (typeof module !== 'undefined' && module.exports) {\n\t        module.exports = Mousetrap;\n\t    }\n\t\n\t    // expose mousetrap as an AMD module\n\t    if (true) {\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t            return Mousetrap;\n\t        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** clappr-playback-control-plugin.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"<%=baseUrl%>/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 96a71d191c67f51c6c80\n **/","/* global PLUGIN_VERSION */\n// node\n// vendors\nimport Clappr from 'clappr';\nimport MouseTrap from 'mousetrap';\n// project\nimport PlaybackControlHTML from './view.html';\nimport PlaybackControlCSS from './style.scss';\n\n// locals\nconst SCALE_FRAMES = 'frames';\nconst SCALE_SECONDS = 'seconds';\nconst BUTTON_STATE_DOWN = 'down';\nconst BUTTON_STATE_UP = 'up';\n\nconst FPS_DEFAULT = 29;\n\nclass PlaybackControl extends Clappr.UICorePlugin {\n  // properties\n  get name() { return 'playback_control'; }\n  get version() { return PLUGIN_VERSION; }\n  get template() { return Clappr.template(PlaybackControlHTML); }\n  get attributes() { return { class: 'playback-control' }; }\n  get mediaControl() { return this.core.mediaControl; }\n  get player() { return this.mediaControl.container; }\n  get config() { return this.core.options.playbackControlConfig || { keyBindings: [] }; }\n  // methods\n  onContainerChanged() {\n    this.invalidate();\n  }\n  seekScaleValue(scale, value) {\n    switch (scale) {\n    case SCALE_FRAMES:\n      this.seekRelativeFrames(value);\n      break;\n    case SCALE_SECONDS:\n      this.seekRelativeSeconds(value);\n      break;\n    default:\n      break;\n    }\n  }\n  findButton(scale, value) {\n    const signed = value > 0 ? `+${value}` : value;\n    return this.$el.find(`[data-step-scale=\"${scale}\"][data-step-value=\"${signed}\"]`);\n  }\n  highlightButton(scale, value, state) {\n    const button = this.findButton(scale, value);\n    switch (state) {\n    case BUTTON_STATE_DOWN:\n      button.children()[1].className = 'playback-control-action-highlight';\n      break;\n    case BUTTON_STATE_UP:\n      button.children()[1].className = '';\n      break;\n    default:\n      break;\n    }\n    return button;\n  }\n  onButtonClick(e) {\n    const sender = e.currentTarget;\n    const scale = sender.getAttribute('data-step-scale');\n    const value = Number(sender.getAttribute('data-step-value'));\n    // control player\n    this.seekScaleValue(scale, value);\n  }\n  onActionsMouseWheel(e) {\n    const sender = e.currentTarget;\n    const scale = sender.getAttribute('data-step-scale');\n    const value = ((e.detail < 0) || (e.wheelDelta > 0)) ? 1 : -1;\n    this.seekScaleValue(scale, value);\n    e.stopPropagation();\n    e.preventDefault();\n    return false;\n  }\n  bindEvents() {\n    // const config = this.config;\n    const player = this.player;\n    this.listenTo(this.mediaControl, Clappr.Events.MEDIACONTROL_RENDERED, this.render);\n    this.listenTo(this.mediaControl, Clappr.Events.MEDIACONTROL_CONTAINERCHANGED, this.onContainerChanged);\n    // non-clappr events\n    MouseTrap.addKeycodes({ 144: 'numlock' });\n    // standard keyboard shortcuts\n    MouseTrap.bind('q', () => this.highlightButton(SCALE_SECONDS, -1, BUTTON_STATE_DOWN), 'keydown');\n    MouseTrap.bind('q', () => {\n      this.highlightButton(SCALE_SECONDS, -1, BUTTON_STATE_UP);\n      this.seekRelativeSeconds(-1);\n    }, 'keyup');\n    MouseTrap.bind('w', () => this.highlightButton(SCALE_SECONDS, +1, BUTTON_STATE_DOWN), 'keydown');\n    MouseTrap.bind('w', () => {\n      this.highlightButton(SCALE_SECONDS, +1, BUTTON_STATE_UP);\n      this.seekRelativeSeconds(+1);\n    }, 'keyup');\n    MouseTrap.bind('a', () => this.highlightButton(SCALE_FRAMES, -1, BUTTON_STATE_DOWN), 'keydown');\n    MouseTrap.bind('a', () => {\n      this.highlightButton(SCALE_FRAMES, -1, BUTTON_STATE_UP);\n      this.seekRelativeFrames(-1);\n    }, 'keyup');\n    MouseTrap.bind('s', () => this.highlightButton(SCALE_FRAMES, +1, BUTTON_STATE_DOWN), 'keydown');\n    MouseTrap.bind('s', () => {\n      this.highlightButton(SCALE_FRAMES, +1, BUTTON_STATE_UP);\n      this.seekRelativeFrames(+1);\n    }, 'keyup');\n    MouseTrap.bind('space', () => {\n      if (player.isPlaying()) {\n        player.pause();\n      } else {\n        player.play();\n      }\n    });\n    // shuttle xpress - large wheel with arrow keys fallback(time control)\n    MouseTrap.bind('up', () => this.seekRelativeSeconds(-1));\n    MouseTrap.bind('down', () => this.seekRelativeSeconds(+1));\n    // shuttle xpress - small wheel with arrow keys fallback(time control)\n    MouseTrap.bind('left', () => this.seekRelativeFrames(-1));\n    MouseTrap.bind('right', () => this.seekRelativeFrames(+1));\n    // shuttle xpress - small wheel with ctrl +/- keys combo fallback(frame control)\n    MouseTrap.bind('ctrl+-', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.seekRelativeFrames(-1);\n    });\n    MouseTrap.bind(['ctrl+=', 'ctrl+plus'], (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.seekRelativeFrames(+1);\n    });\n    // shuttle express - buttons(numeric keys fallback)\n    const switchPlaybackRate = (e, rate) => {\n      e.preventDefault();\n      e.stopPropagation();\n      this.mediaControl.trigger('playbackRate', rate);\n      return false;\n    };\n    MouseTrap.bind('0', (e) => switchPlaybackRate(e, 0.5));\n    MouseTrap.bind(['1', 'numlock+alt+left'], (e) => switchPlaybackRate(e, 1));\n    MouseTrap.bind(['2', 'numlock+ctrl+h'], (e) => switchPlaybackRate(e, 2));\n    MouseTrap.bind(['3', 'ctrl+shift+o', 'numlock+ctrl+i'], (e) => switchPlaybackRate(e, 3));\n    MouseTrap.bind(['4', 'numlock+ctrl+t'], (e) => switchPlaybackRate(e, 4));\n    MouseTrap.bind(['5', 'numlock+alt+right'], (e) => switchPlaybackRate(e, 5));\n    MouseTrap.bind('6', (e) => switchPlaybackRate(e, 6));\n    MouseTrap.bind('7', (e) => switchPlaybackRate(e, 7));\n    MouseTrap.bind('8', (e) => switchPlaybackRate(e, 8));\n    MouseTrap.bind('9', (e) => switchPlaybackRate(e, 9));\n  }\n  stopListening() {\n    super.stopListening();\n    // non-clappr events\n    if (this.onMouseWheelDelegate) {\n      this.onMouseWheelDelegate.unbind();\n      this.onMouseWheelDelegate = null;\n    }\n  }\n  render() {\n    const style = Clappr.Styler.getStyleFor(PlaybackControlCSS);\n    this.$el\n      .html(this.template())\n      .append(style);\n    this.$el\n      .find('[type=\"button\"]')\n      .off('click')\n      .on('click', this.onButtonClick.bind(this));\n    this.$el\n      .find('.playback-control-actions')\n      .off('DOMMouseScroll')\n      .on('DOMMouseScroll', this.onActionsMouseWheel.bind(this));\n    this.$el\n      .find('.playback-control-actions')\n      .off('mousewheel')\n      .on('mousewheel', this.onActionsMouseWheel.bind(this));\n    this.mediaControl\n      .$('.media-control-left-panel[data-media-control]')\n      .append(this.el);\n    return this;\n  }\n  invalidate() {\n    this.stopListening();\n    this.bindEvents();\n  }\n  getFPS() {\n    let fps = FPS_DEFAULT;\n    if (this.player && this.player.options && this.player.options.playbackControl) {\n      fps = this.player.options.playbackControl.fps || fps;\n    }\n    return fps;\n  }\n  seekRelativeFrames(frames) {\n    const player = this.player;\n    if (player.isPlaying()) {\n      player.pause();\n    }\n    const currentTime = player.getCurrentTime();\n    const targetTime = currentTime + (frames / this.getFPS());\n    if ((targetTime <= 0) || (targetTime >= player.getDuration())) {\n      // TODO: decide on how to norm bounds\n    } else {\n      const playback = this.core.getCurrentPlayback();\n      player.seek(targetTime);\n      // Trigger the waiting event that will buffer the video if targetTime is not buffered yet\n      const bufferedTimeRange = playback.el.buffered;\n      let targetFrameBuffered = false;\n      for (let i = 0; i < bufferedTimeRange.length; i++) {\n        if ((targetTime >= bufferedTimeRange.start(i)) && (targetTime <= bufferedTimeRange.end(i))) {\n          targetFrameBuffered = true;\n          break;\n        }\n      }\n      if (!targetFrameBuffered) {\n        playback.trigger('waiting');\n      }\n    }\n  }\n  seekRelativeSeconds(seconds) {\n    const player = this.player;\n    if (player.isPlaying()) {\n      player.pause();\n    }\n    let position = player.getCurrentTime() + seconds;\n    if (position < 0) {\n      position = 0;\n    } else if (position > player.getDuration()) {\n      position = player.getDuration();\n    }\n    player.seek(position);\n  }\n}\n\nexport default PlaybackControl;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/plugin.js\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"[data-player] div.playback-control{float:left}[data-player] div.playback-control>.playback-control-actions{display:inline-block;margin-left:1px;margin-right:1px;height:28px}[data-player] div.playback-control>.playback-control-actions:hover{background:#eee}[data-player] div.playback-control>.playback-control-actions>button{outline:none;cursor:pointer;border:1px solid #444;margin:1px;text-align:center;width:35px;height:26px}[data-player] div.playback-control>.playback-control-actions>button>sub{outline:none;position:relative;display:inline-block;background:#eee;border-radius:15px;width:25px;border:1px solid;left:-2px;bottom:0;font-weight:700;font-family:Consolas,Lucida Console,Monaco,monospace;font-size:11px}[data-player] div.playback-control>.playback-control-actions>button>sub.playback-control-action-highlight{background:#febf04;border-color:#333;color:#333;position:relative;top:1px;left:1px}[data-player] div.playback-control>.playback-control-actions>button:hover{background:#333;color:#eee}[data-player] div.playback-control>.playback-control-actions>button:hover>sub{border-color:#eee;color:#333}[data-player] div.playback-control>.playback-control-actions>button:active{background:#666;color:#333;border-color:#111;position:relative;top:1px}[data-player] div.playback-control>.playback-control-actions>button:active>sub{background:#111;color:#666;border-color:#111;font-weight:700}[data-player] div.playback-control>.playback-control-actions>button::-moz-focus-inner{border:0}[data-player] div.playback-control>.playback-control-actions[data-step-scale=seconds]>button{background:#00b7ea}[data-player] div.playback-control>.playback-control-actions[data-step-scale=frames]>button{background:#d2ff52}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/style.scss\n ** module id = 1\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = \"<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"seconds\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second backward\\\">\\n    <p>-1</p>\\n    <sub>Q</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"seconds\\\" title=\\\"Step 1 second forward\\\">\\n    <p>+1</p>\\n    <sub>W</sub>\\n  </button>\\n</div>\\n<div class=\\\"playback-control-actions\\\" data-step-scale=\\\"frames\\\">\\n  <button type=\\\"button\\\" data-step-value=\\\"-1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame backward\\\">\\n    <p>-1</p>\\n    <sub>A</sub>\\n  </button>\\n  <button type=\\\"button\\\" data-step-value=\\\"+1\\\" data-step-scale=\\\"frames\\\" title=\\\"Step 1 frame forward\\\">\\n    <p>+1</p>\\n    <sub>S</sub>\\n  </button>\\n</div>\\n\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/view.html\n ** module id = 3\n ** module chunks = 0\n **/","/*global define:false */\n/**\n * Copyright 2016 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.0\n * @url craig.is/killing/mice\n */\n(function(window, document, undefined) {\n\n    // Check if mousetrap is used inside browser, if not, return\n    if (!window) {\n        return;\n    }\n\n    /**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */\n    var _MAP = {\n        8: 'backspace',\n        9: 'tab',\n        13: 'enter',\n        16: 'shift',\n        17: 'ctrl',\n        18: 'alt',\n        20: 'capslock',\n        27: 'esc',\n        32: 'space',\n        33: 'pageup',\n        34: 'pagedown',\n        35: 'end',\n        36: 'home',\n        37: 'left',\n        38: 'up',\n        39: 'right',\n        40: 'down',\n        45: 'ins',\n        46: 'del',\n        91: 'meta',\n        93: 'meta',\n        224: 'meta'\n    };\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    var _KEYCODE_MAP = {\n        106: '*',\n        107: '+',\n        109: '-',\n        110: '.',\n        111 : '/',\n        186: ';',\n        187: '=',\n        188: ',',\n        189: '-',\n        190: '.',\n        191: '/',\n        192: '`',\n        219: '[',\n        220: '\\\\',\n        221: ']',\n        222: '\\''\n    };\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    var _SHIFT_MAP = {\n        '~': '`',\n        '!': '1',\n        '@': '2',\n        '#': '3',\n        '$': '4',\n        '%': '5',\n        '^': '6',\n        '&': '7',\n        '*': '8',\n        '(': '9',\n        ')': '0',\n        '_': '-',\n        '+': '=',\n        ':': ';',\n        '\\\"': '\\'',\n        '<': ',',\n        '>': '.',\n        '?': '/',\n        '|': '\\\\'\n    };\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    var _SPECIAL_ALIASES = {\n        'option': 'alt',\n        'command': 'meta',\n        'return': 'enter',\n        'escape': 'esc',\n        'plus': '+',\n        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    };\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    var _REVERSE_MAP;\n\n    /**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */\n    for (var i = 1; i < 20; ++i) {\n        _MAP[111 + i] = 'f' + i;\n    }\n\n    /**\n     * loop through to map numbers on the numeric keypad\n     */\n    for (i = 0; i <= 9; ++i) {\n        _MAP[i + 96] = i;\n    }\n\n    /**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */\n    function _addEvent(object, type, callback) {\n        if (object.addEventListener) {\n            object.addEventListener(type, callback, false);\n            return;\n        }\n\n        object.attachEvent('on' + type, callback);\n    }\n\n    /**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */\n    function _characterFromEvent(e) {\n\n        // for keypress events we should return the character as is\n        if (e.type == 'keypress') {\n            var character = String.fromCharCode(e.which);\n\n            // if the shift key is not pressed then it is safe to assume\n            // that we want the character to be lowercase.  this means if\n            // you accidentally have caps lock on then your key bindings\n            // will continue to work\n            //\n            // the only side effect that might not be desired is if you\n            // bind something like 'A' cause you want to trigger an\n            // event when capital A is pressed caps lock will no longer\n            // trigger the event.  shift+a will though.\n            if (!e.shiftKey) {\n                character = character.toLowerCase();\n            }\n\n            return character;\n        }\n\n        // for non keypress events the special maps are needed\n        if (_MAP[e.which]) {\n            return _MAP[e.which];\n        }\n\n        if (_KEYCODE_MAP[e.which]) {\n            return _KEYCODE_MAP[e.which];\n        }\n\n        // if it is not in the special map\n\n        // with keydown and keyup events the character seems to always\n        // come in as an uppercase character whether you are pressing shift\n        // or not.  we should make sure it is always lowercase for comparisons\n        return String.fromCharCode(e.which).toLowerCase();\n    }\n\n    /**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */\n    function _modifiersMatch(modifiers1, modifiers2) {\n        return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n    }\n\n    /**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */\n    function _eventModifiers(e) {\n        var modifiers = [];\n\n        if (e.shiftKey) {\n            modifiers.push('shift');\n        }\n\n        if (e.altKey) {\n            modifiers.push('alt');\n        }\n\n        if (e.ctrlKey) {\n            modifiers.push('ctrl');\n        }\n\n        if (e.metaKey) {\n            modifiers.push('meta');\n        }\n\n        return modifiers;\n    }\n\n    /**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _preventDefault(e) {\n        if (e.preventDefault) {\n            e.preventDefault();\n            return;\n        }\n\n        e.returnValue = false;\n    }\n\n    /**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */\n    function _stopPropagation(e) {\n        if (e.stopPropagation) {\n            e.stopPropagation();\n            return;\n        }\n\n        e.cancelBubble = true;\n    }\n\n    /**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */\n    function _isModifier(key) {\n        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n    }\n\n    /**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */\n    function _getReverseMap() {\n        if (!_REVERSE_MAP) {\n            _REVERSE_MAP = {};\n            for (var key in _MAP) {\n\n                // pull out the numeric keypad from here cause keypress should\n                // be able to detect the keys from the character\n                if (key > 95 && key < 112) {\n                    continue;\n                }\n\n                if (_MAP.hasOwnProperty(key)) {\n                    _REVERSE_MAP[_MAP[key]] = key;\n                }\n            }\n        }\n        return _REVERSE_MAP;\n    }\n\n    /**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */\n    function _pickBestAction(key, modifiers, action) {\n\n        // if no action was picked in we should try to pick the one\n        // that we think would work best for this key\n        if (!action) {\n            action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n        }\n\n        // modifier keys don't work as expected with keypress,\n        // switch to keydown\n        if (action == 'keypress' && modifiers.length) {\n            action = 'keydown';\n        }\n\n        return action;\n    }\n\n    /**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */\n    function _keysFromString(combination) {\n        if (combination === '+') {\n            return ['+'];\n        }\n\n        combination = combination.replace(/\\+{2}/g, '+plus');\n        return combination.split('+');\n    }\n\n    /**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */\n    function _getKeyInfo(combination, action) {\n        var keys;\n        var key;\n        var i;\n        var modifiers = [];\n\n        // take the keys from this pattern and figure out what the actual\n        // pattern is all about\n        keys = _keysFromString(combination);\n\n        for (i = 0; i < keys.length; ++i) {\n            key = keys[i];\n\n            // normalize key names\n            if (_SPECIAL_ALIASES[key]) {\n                key = _SPECIAL_ALIASES[key];\n            }\n\n            // if this is not a keypress event then we should\n            // be smart about using shift keys\n            // this will only work for US keyboards however\n            if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n                key = _SHIFT_MAP[key];\n                modifiers.push('shift');\n            }\n\n            // if this key is a modifier then add it to the list of modifiers\n            if (_isModifier(key)) {\n                modifiers.push(key);\n            }\n        }\n\n        // depending on what the key combination is\n        // we will try to pick the best event for it\n        action = _pickBestAction(key, modifiers, action);\n\n        return {\n            key: key,\n            modifiers: modifiers,\n            action: action\n        };\n    }\n\n    function _belongsTo(element, ancestor) {\n        if (element === null || element === document) {\n            return false;\n        }\n\n        if (element === ancestor) {\n            return true;\n        }\n\n        return _belongsTo(element.parentNode, ancestor);\n    }\n\n    function Mousetrap(targetElement) {\n        var self = this;\n\n        targetElement = targetElement || document;\n\n        if (!(self instanceof Mousetrap)) {\n            return new Mousetrap(targetElement);\n        }\n\n        /**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */\n        self.target = targetElement;\n\n        /**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */\n        self._callbacks = {};\n\n        /**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */\n        self._directMap = {};\n\n        /**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */\n        var _sequenceLevels = {};\n\n        /**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */\n        var _resetTimer;\n\n        /**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */\n        var _ignoreNextKeyup = false;\n\n        /**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */\n        var _ignoreNextKeypress = false;\n\n        /**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */\n        var _nextExpectedAction = false;\n\n        /**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */\n        function _resetSequences(doNotReset) {\n            doNotReset = doNotReset || {};\n\n            var activeSequences = false,\n                key;\n\n            for (key in _sequenceLevels) {\n                if (doNotReset[key]) {\n                    activeSequences = true;\n                    continue;\n                }\n                _sequenceLevels[key] = 0;\n            }\n\n            if (!activeSequences) {\n                _nextExpectedAction = false;\n            }\n        }\n\n        /**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */\n        function _getMatches(character, modifiers, e, sequenceName, combination, level) {\n            var i;\n            var callback;\n            var matches = [];\n            var action = e.type;\n\n            // if there are no events related to this keycode\n            if (!self._callbacks[character]) {\n                return [];\n            }\n\n            // if a modifier key is coming up on its own we should allow it\n            if (action == 'keyup' && _isModifier(character)) {\n                modifiers = [character];\n            }\n\n            // loop through all callbacks for the key that was pressed\n            // and see if any of them match\n            for (i = 0; i < self._callbacks[character].length; ++i) {\n                callback = self._callbacks[character][i];\n\n                // if a sequence name is not specified, but this is a sequence at\n                // the wrong level then move onto the next match\n                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n                    continue;\n                }\n\n                // if the action we are looking for doesn't match the action we got\n                // then we should keep going\n                if (action != callback.action) {\n                    continue;\n                }\n\n                // if this is a keypress event and the meta key and control key\n                // are not pressed that means that we need to only look at the\n                // character, otherwise check the modifiers as well\n                //\n                // chrome will not fire a keypress if meta or control is down\n                // safari will fire a keypress if meta or meta+shift is down\n                // firefox will fire a keypress if meta or control is down\n                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n                    // when you bind a combination or sequence a second time it\n                    // should overwrite the first one.  if a sequenceName or\n                    // combination is specified in this call it does just that\n                    //\n                    // @todo make deleting its own method?\n                    var deleteCombo = !sequenceName && callback.combo == combination;\n                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n                    if (deleteCombo || deleteSequence) {\n                        self._callbacks[character].splice(i, 1);\n                    }\n\n                    matches.push(callback);\n                }\n            }\n\n            return matches;\n        }\n\n        /**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */\n        function _fireCallback(callback, e, combo, sequence) {\n\n            // if this event should not happen stop here\n            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n                return;\n            }\n\n            if (callback(e, combo) === false) {\n                _preventDefault(e);\n                _stopPropagation(e);\n            }\n        }\n\n        /**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */\n        self._handleKey = function(character, modifiers, e) {\n            var callbacks = _getMatches(character, modifiers, e);\n            var i;\n            var doNotReset = {};\n            var maxLevel = 0;\n            var processedSequenceCallback = false;\n\n            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n            for (i = 0; i < callbacks.length; ++i) {\n                if (callbacks[i].seq) {\n                    maxLevel = Math.max(maxLevel, callbacks[i].level);\n                }\n            }\n\n            // loop through matching callbacks for this key event\n            for (i = 0; i < callbacks.length; ++i) {\n\n                // fire for all sequence callbacks\n                // this is because if for example you have multiple sequences\n                // bound such as \"g i\" and \"g t\" they both need to fire the\n                // callback for matching g cause otherwise you can only ever\n                // match the first one\n                if (callbacks[i].seq) {\n\n                    // only fire callbacks for the maxLevel to prevent\n                    // subsequences from also firing\n                    //\n                    // for example 'a option b' should not cause 'option b' to fire\n                    // even though 'option b' is part of the other sequence\n                    //\n                    // any sequences that do not match here will be discarded\n                    // below by the _resetSequences call\n                    if (callbacks[i].level != maxLevel) {\n                        continue;\n                    }\n\n                    processedSequenceCallback = true;\n\n                    // keep a list of which sequences were matches for later\n                    doNotReset[callbacks[i].seq] = 1;\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n                    continue;\n                }\n\n                // if there were no sequence matches but we are still here\n                // that means this is a regular match so we should fire that\n                if (!processedSequenceCallback) {\n                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n                }\n            }\n\n            // if the key you pressed matches the type of sequence without\n            // being a modifier (ie \"keyup\" or \"keypress\") then we should\n            // reset all sequences that were not matched by this event\n            //\n            // this is so, for example, if you have the sequence \"h a t\" and you\n            // type \"h e a r t\" it does not match.  in this case the \"e\" will\n            // cause the sequence to reset\n            //\n            // modifier keys are ignored because you can have a sequence\n            // that contains modifiers such as \"enter ctrl+space\" and in most\n            // cases the modifier key will be pressed before the next key\n            //\n            // also if you have a sequence such as \"ctrl+b a\" then pressing the\n            // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n            //\n            // the \"keydown\" is expected when there is a modifier, but the\n            // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n            // after and that causes the sequence to reset\n            //\n            // we ignore keypresses in a sequence that directly follow a keydown\n            // for the same character\n            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n                _resetSequences(doNotReset);\n            }\n\n            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n        };\n\n        /**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */\n        function _handleKeyEvent(e) {\n\n            // normalize e.which for key events\n            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n            if (typeof e.which !== 'number') {\n                e.which = e.keyCode;\n            }\n\n            var character = _characterFromEvent(e);\n\n            // no character found then stop\n            if (!character) {\n                return;\n            }\n\n            // need to use === for the character check because the character can be 0\n            if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n                _ignoreNextKeyup = false;\n                return;\n            }\n\n            self.handleKey(character, _eventModifiers(e), e);\n        }\n\n        /**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */\n        function _resetSequenceTimer() {\n            clearTimeout(_resetTimer);\n            _resetTimer = setTimeout(_resetSequences, 1000);\n        }\n\n        /**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */\n        function _bindSequence(combo, keys, callback, action) {\n\n            // start off by adding a sequence level record for this combination\n            // and setting the level to 0\n            _sequenceLevels[combo] = 0;\n\n            /**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */\n            function _increaseSequence(nextAction) {\n                return function() {\n                    _nextExpectedAction = nextAction;\n                    ++_sequenceLevels[combo];\n                    _resetSequenceTimer();\n                };\n            }\n\n            /**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */\n            function _callbackAndReset(e) {\n                _fireCallback(callback, e, combo);\n\n                // we should ignore the next key up if the action is key down\n                // or keypress.  this is so if you finish a sequence and\n                // release the key the final key will not trigger a keyup\n                if (action !== 'keyup') {\n                    _ignoreNextKeyup = _characterFromEvent(e);\n                }\n\n                // weird race condition if a sequence ends with the key\n                // another sequence begins with\n                setTimeout(_resetSequences, 10);\n            }\n\n            // loop through keys one at a time and bind the appropriate callback\n            // function.  for any key leading up to the final one it should\n            // increase the sequence. after the final, it should reset all sequences\n            //\n            // if an action is specified in the original bind call then that will\n            // be used throughout.  otherwise we will pass the action that the\n            // next key in the sequence should match.  this allows a sequence\n            // to mix and match keypress and keydown events depending on which\n            // ones are better suited to the key provided\n            for (var i = 0; i < keys.length; ++i) {\n                var isFinal = i + 1 === keys.length;\n                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n                _bindSingle(keys[i], wrappedCallback, action, combo, i);\n            }\n        }\n\n        /**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */\n        function _bindSingle(combination, callback, action, sequenceName, level) {\n\n            // store a direct mapped reference for use with Mousetrap.trigger\n            self._directMap[combination + ':' + action] = callback;\n\n            // make sure multiple spaces in a row become a single space\n            combination = combination.replace(/\\s+/g, ' ');\n\n            var sequence = combination.split(' ');\n            var info;\n\n            // if this pattern is a sequence of keys then run through this method\n            // to reprocess each pattern one key at a time\n            if (sequence.length > 1) {\n                _bindSequence(combination, sequence, callback, action);\n                return;\n            }\n\n            info = _getKeyInfo(combination, action);\n\n            // make sure to initialize array if this is the first time\n            // a callback is added for this key\n            self._callbacks[info.key] = self._callbacks[info.key] || [];\n\n            // remove an existing match if there is one\n            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n            // add this call back to the array\n            // if it is a sequence put it at the beginning\n            // if not put it at the end\n            //\n            // this is important because the way these are processed expects\n            // the sequence ones to come first\n            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n                callback: callback,\n                modifiers: info.modifiers,\n                action: info.action,\n                seq: sequenceName,\n                level: level,\n                combo: combination\n            });\n        }\n\n        /**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */\n        self._bindMultiple = function(combinations, callback, action) {\n            for (var i = 0; i < combinations.length; ++i) {\n                _bindSingle(combinations[i], callback, action);\n            }\n        };\n\n        // start!\n        _addEvent(targetElement, 'keypress', _handleKeyEvent);\n        _addEvent(targetElement, 'keydown', _handleKeyEvent);\n        _addEvent(targetElement, 'keyup', _handleKeyEvent);\n    }\n\n    /**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */\n    Mousetrap.prototype.bind = function(keys, callback, action) {\n        var self = this;\n        keys = keys instanceof Array ? keys : [keys];\n        self._bindMultiple.call(self, keys, callback, action);\n        return self;\n    };\n\n    /**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */\n    Mousetrap.prototype.unbind = function(keys, action) {\n        var self = this;\n        return self.bind.call(self, keys, function() {}, action);\n    };\n\n    /**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */\n    Mousetrap.prototype.trigger = function(keys, action) {\n        var self = this;\n        if (self._directMap[keys + ':' + action]) {\n            self._directMap[keys + ':' + action]({}, keys);\n        }\n        return self;\n    };\n\n    /**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */\n    Mousetrap.prototype.reset = function() {\n        var self = this;\n        self._callbacks = {};\n        self._directMap = {};\n        return self;\n    };\n\n    /**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */\n    Mousetrap.prototype.stopCallback = function(e, element) {\n        var self = this;\n\n        // if the element has the class \"mousetrap\" then no need to stop\n        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n            return false;\n        }\n\n        if (_belongsTo(element, self.target)) {\n            return false;\n        }\n\n        // stop for input, select, and textarea\n        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n    };\n\n    /**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */\n    Mousetrap.prototype.handleKey = function() {\n        var self = this;\n        return self._handleKey.apply(self, arguments);\n    };\n\n    /**\n     * allow custom key mappings\n     */\n    Mousetrap.addKeycodes = function(object) {\n        for (var key in object) {\n            if (object.hasOwnProperty(key)) {\n                _MAP[key] = object[key];\n            }\n        }\n        _REVERSE_MAP = null;\n    };\n\n    /**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */\n    Mousetrap.init = function() {\n        var documentMousetrap = Mousetrap(document);\n        for (var method in documentMousetrap) {\n            if (method.charAt(0) !== '_') {\n                Mousetrap[method] = (function(method) {\n                    return function() {\n                        return documentMousetrap[method].apply(documentMousetrap, arguments);\n                    };\n                } (method));\n            }\n        }\n    };\n\n    Mousetrap.init();\n\n    // expose mousetrap to the global object\n    window.Mousetrap = Mousetrap;\n\n    // expose as a common js module\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = Mousetrap;\n    }\n\n    // expose mousetrap as an AMD module\n    if (typeof define === 'function' && define.amd) {\n        define(function() {\n            return Mousetrap;\n        });\n    }\n}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/mousetrap/mousetrap.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"clappr\"\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}